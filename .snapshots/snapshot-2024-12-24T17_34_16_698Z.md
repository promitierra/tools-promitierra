Enter your prompt here

# Project Structure

â”œâ”€ ğŸ“ src
  â”œâ”€ ğŸ“ utils
    â””â”€ __init__.py
    â””â”€ helpers.py
  â”œâ”€ ğŸ“ gui
    â””â”€ __init__.py
    â””â”€ main_window.py
  â”œâ”€ ğŸ“ core
    â””â”€ __init__.py
    â””â”€ text_normalizer.py
    â””â”€ image_processor.py
    â””â”€ folder_creator.py
  â”œâ”€ ğŸ“ app
    â””â”€ __init__.py
    â””â”€ pdf_converter.py
    â””â”€ gui.py
  â””â”€ __init__.py
â”œâ”€ ğŸ“ tests
  â””â”€ __init__.py
  â””â”€ test_text_normalizer.py
  â””â”€ test_pdf_converter.py
  â””â”€ test_main_window.py
  â””â”€ test_image_processor.py
  â””â”€ test_imagen_a_pdf.py
  â””â”€ test_helpers.py
  â””â”€ test_folder_creator.py
  â””â”€ Plantilla Nombres Carpetas.xlsx
  â””â”€ conftest.py
â”œâ”€ ğŸ“ scripts
  â””â”€ create_simple_icon.py
  â””â”€ create_icon.py
â”œâ”€ ğŸ“ .pytest_cache
  â”œâ”€ ğŸ“ v
    â”œâ”€ ğŸ“ cache
      â””â”€ stepwise
      â””â”€ nodeids
      â””â”€ lastfailed
  â””â”€ README.md
  â””â”€ CACHEDIR.TAG
â””â”€ ROADMAP.md
â””â”€ requirements.txt
â””â”€ README.md
â””â”€ main.py
â””â”€ imagen_a_pdf.py
â””â”€ icon.py
â””â”€ CHANGELOG.md


# Project Files

- tests\__init__.py
- tests\test_text_normalizer.py
- tests\test_pdf_converter.py
- tests\test_main_window.py
- tests\test_image_processor.py
- tests\test_imagen_a_pdf.py
- tests\test_helpers.py
- tests\test_folder_creator.py
- tests\Plantilla Nombres Carpetas.xlsx
- tests\conftest.py
- src\gui\__init__.py
- src\gui\main_window.py
- src\__init__.py
- src\utils\__init__.py
- src\utils\helpers.py
- ROADMAP.md
- scripts\create_simple_icon.py
- scripts\create_icon.py
- requirements.txt
- README.md
- main.py
- imagen_a_pdf.py
- icon.py
- CHANGELOG.md
- src\app\gui.py
- src\app\__init__.py
- src\app\pdf_converter.py
- src\core\__init__.py
- src\core\text_normalizer.py
- src\core\image_processor.py
- src\core\folder_creator.py
- .pytest_cache\v\cache\stepwise
- .pytest_cache\v\cache\nodeids
- .pytest_cache\v\cache\lastfailed
- .pytest_cache\README.md
- .pytest_cache\CACHEDIR.TAG

## tests\__init__.py
```


```

## tests\test_text_normalizer.py
```
"""
Comprehensive unit tests for TextNormalizer class.
"""
import unittest
import random
import string
from src.core.text_normalizer import TextNormalizer

class TestTextNormalizer(unittest.TestCase):
    """Comprehensive test suite for TextNormalizer."""
    
    def setUp(self):
        """Initialize TextNormalizer for each test."""
        self.normalizer = TextNormalizer()
    
    def _generate_random_string(self, length=10, include_special_chars=False):
        """Generate a random string for testing."""
        chars = string.ascii_letters + string.digits
        if include_special_chars:
            chars += "!@#$%^&*()_+-=[]{}|;:,.<>?"
        return ''.join(random.choice(chars) for _ in range(length))
    
    def test_basic_normalization(self):
        """Test basic text normalization."""
        test_cases = [
            ("Hello World", "HELLO WORLD"),
            ("  Trimmed  Spaces  ", "TRIMMED SPACES"),
            ("mÃºltiplÃ© Ã¡ccents", "MULTIPLE ACCENTS"),
        ]
        
        for input_text, expected in test_cases:
            with self.subTest(input=input_text):
                normalized = self.normalizer.normalize_text(input_text)
                self.assertEqual(normalized, expected)
    
    def test_special_characters(self):
        """Test handling of special characters."""
        test_cases = [
            ("Hello, World!", "HELLO WORLD"),
            ("File.name", "FILE_NAME"),
            ("User#123", "USER_123"),
            ("Special@Chars", "SPECIAL_CHARS"),
            ("Dash-Separated", "DASH-SEPARATED"),
        ]
        
        for input_text, expected in test_cases:
            with self.subTest(input=input_text):
                normalized = self.normalizer.normalize_text(input_text)
                self.assertEqual(normalized, expected)
    
    def test_complex_names(self):
        """Test normalization of complex names and IDs."""
        test_cases = [
            ("1515 15 - LUI S FER NANDO", "1515 15 - LUIS FERNANDO"),
            ("  Juan   Manuel   PÃ©rez  ", "JUAN MANUEL PEREZ"),
            ("1.515.15 - Luis, Fernando", "1_515_15 - LUIS FERNANDO"),
            ("  1515 15 . LUI S , FER NANDO  ", "1515 15 - LUIS FERNANDO"),
            ("Juan2 PÃ©rez3", "JUAN2 PEREZ3"),
        ]
        
        for input_text, expected in test_cases:
            with self.subTest(input=input_text):
                normalized = self.normalizer.normalize_text(input_text)
                self.assertEqual(normalized, expected)
    
    def test_edge_cases(self):
        """Test edge cases and boundary conditions."""
        test_cases = [
            ("", ""),  # Empty string
            ("   ", ""),  # Only whitespace
            ("a" * 1000, "A" * 1000),  # Very long string
            ("!@#$%^&*()", ""),  # Only special characters
        ]
        
        for input_text, expected in test_cases:
            with self.subTest(input=input_text):
                normalized = self.normalizer.normalize_text(input_text)
                self.assertEqual(normalized, expected)
    
    def test_unicode_characters(self):
        """Test handling of Unicode characters."""
        test_cases = [
            ("CafÃ©", "CAFE"),
            ("SeÃ±or", "SENOR"),
            ("AÃ±o Nuevo", "ANO NUEVO"),
            ("ã“ã‚“ã«ã¡ã¯", ""),  # Non-Latin characters
        ]
        
        for input_text, expected in test_cases:
            with self.subTest(input=input_text):
                normalized = self.normalizer.normalize_text(input_text)
                self.assertEqual(normalized, expected)
    
    def test_random_input_robustness(self):
        """Test robustness with random input."""
        for _ in range(100):  # Run 100 random tests
            # Generate random strings with and without special characters
            random_str = self._generate_random_string(
                length=random.randint(1, 50), 
                include_special_chars=random.choice([True, False])
            )
            
            try:
                normalized = self.normalizer.normalize_text(random_str)
                # Basic assertions
                self.assertTrue(isinstance(normalized, str))
                self.assertTrue(all(c.isalnum() or c in '-_' for c in normalized))
            except Exception as e:
                self.fail(f"Unexpected error with input '{random_str}': {e}")
    
    def test_performance(self):
        """Basic performance test for normalization."""
        import timeit
        
        # Test normalization time for a moderately long string
        long_string = " ".join([self._generate_random_string() for _ in range(10)])
        
        def normalize_test():
            self.normalizer.normalize_text(long_string)
        
        # Ensure normalization takes less than 0.01 seconds
        execution_time = timeit.timeit(normalize_test, number=1000) / 1000
        self.assertLess(execution_time, 0.01, 
            "Normalization is taking too long. Consider optimizing.")

if __name__ == '__main__':
    unittest.main()

```

## tests\test_pdf_converter.py
```
import unittest
import os
import tempfile
import shutil
import time
from concurrent.futures import ThreadPoolExecutor
from src.app.pdf_converter import PDFConverter
from PIL import Image

class TestPDFConverter(unittest.TestCase):
    def setUp(self):
        """ConfiguraciÃ³n inicial para cada prueba"""
        self.temp_dir = tempfile.mkdtemp()
        self.converter = PDFConverter()
        
        # Crear imÃ¡genes de prueba
        self.crear_imagenes_prueba()
        
    def tearDown(self):
        """Limpieza despuÃ©s de cada prueba"""
        if os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)
    
    def crear_imagenes_prueba(self):
        """Crear imÃ¡genes de prueba en diferentes formatos"""
        # Imagen RGB normal
        img_rgb = Image.new('RGB', (100, 100), color='red')
        img_rgb.save(os.path.join(self.temp_dir, 'test_rgb.png'))
        
        # Imagen RGBA con transparencia
        img_rgba = Image.new('RGBA', (100, 100), color=(255, 0, 0, 128))
        img_rgba.save(os.path.join(self.temp_dir, 'test_rgba.png'))
        
        # Imagen en escala de grises
        img_gray = Image.new('L', (100, 100), color=128)
        img_gray.save(os.path.join(self.temp_dir, 'test_gray.jpg'))
        
        # Imagen grande para prueba de redimensionamiento
        img_large = Image.new('RGB', (3000, 3000), color='blue')
        img_large.save(os.path.join(self.temp_dir, 'test_large.jpg'))
        
        # Crear una imagen corrupta
        with open(os.path.join(self.temp_dir, 'corrupted.jpg'), 'wb') as f:
            f.write(b'Not an image file')
        
        # Crear subdirectorio con imagen
        os.makedirs(os.path.join(self.temp_dir, 'subdir'))
        img_sub = Image.new('RGB', (100, 100), color='green')
        img_sub.save(os.path.join(self.temp_dir, 'subdir', 'test_sub.png'))
    
    def test_conversion_simple(self):
        """Prueba conversiÃ³n bÃ¡sica de imagen a PDF"""
        class MockCallbacks:
            def __init__(self):
                self.started = False
                self.files_found = 0
                self.converted = []
                self.errors = []
                self.completed = False
                
            def on_start(self): self.started = True
            def on_images_found(self, total): self.files_found = total
            def on_file_converted(self, name): self.converted.append(name)
            def on_file_error(self, name, error): self.errors.append((name, error))
            def on_complete(self, *args): self.completed = True
            def on_progress(self, *args): pass
            def on_processing_file(self, *args): pass
            def on_finish(self): pass
            
        callbacks = MockCallbacks()
        self.converter.procesar_carpeta(self.temp_dir, False, callbacks)
        
        self.assertTrue(callbacks.started)
        self.assertEqual(callbacks.files_found, 6)  # Total de imÃ¡genes
        self.assertEqual(len(callbacks.converted), 5)  # ImÃ¡genes convertidas exitosamente
        self.assertEqual(len(callbacks.errors), 1)  # 1 imagen corrupta
        self.assertTrue(callbacks.completed)
    
    def test_conversion_paralela(self):
        """Prueba que la conversiÃ³n paralela funciona correctamente"""
        tiempos = []
        for num_workers in [1, 2, 4]:  # Probar con diferente nÃºmero de workers
            self.converter.max_workers = num_workers
            
            inicio = time.time()
            class TimingCallbacks:
                def __init__(self):
                    self.completed = False
                def on_start(self): pass
                def on_images_found(self, total): pass
                def on_file_converted(self, name): pass
                def on_file_error(self, name, error): pass
                def on_complete(self, *args): self.completed = True
                def on_progress(self, *args): pass
                def on_processing_file(self, *args): pass
                def on_finish(self): pass
            
            callbacks = TimingCallbacks()
            self.converter.procesar_carpeta(self.temp_dir, False, callbacks)
            tiempo_total = time.time() - inicio
            tiempos.append(tiempo_total)
        
        # El tiempo con mÃ¡s workers deberÃ­a ser menor
        self.assertLess(tiempos[2], tiempos[0])
    
    def test_cancelacion(self):
        """Prueba la funcionalidad de cancelaciÃ³n"""
        class CancelCallbacks:
            def __init__(self):
                self.files_processed = 0
                self.finished = False
            def on_start(self): pass
            def on_images_found(self, total): pass
            def on_file_converted(self, name): self.files_processed += 1
            def on_file_error(self, name, error): pass
            def on_complete(self, *args): pass
            def on_progress(self, *args): pass
            def on_processing_file(self, *args): pass
            def on_finish(self): self.finished = True
        
        callbacks = CancelCallbacks()
        
        # Iniciar conversiÃ³n en un hilo separado
        import threading
        thread = threading.Thread(
            target=self.converter.procesar_carpeta,
            args=(self.temp_dir, False, callbacks)
        )
        thread.start()
        
        # Esperar un momento y cancelar
        time.sleep(0.1)
        self.converter.cancelar_proceso()
        thread.join()
        
        # Verificar que se cancelÃ³ correctamente
        self.assertTrue(callbacks.finished)
        self.assertLess(callbacks.files_processed, 6)  # No todas las imÃ¡genes procesadas
    
    def test_manejo_memoria(self):
        """Prueba el manejo de memoria con imÃ¡genes grandes"""
        # Crear una imagen muy grande
        img_huge = Image.new('RGB', (4000, 4000), color='red')
        huge_path = os.path.join(self.temp_dir, 'huge.jpg')
        img_huge.save(huge_path)
        
        class MemoryCallbacks:
            def __init__(self):
                self.converted = []
            def on_start(self): pass
            def on_images_found(self, total): pass
            def on_file_converted(self, name): self.converted.append(name)
            def on_file_error(self, name, error): pass
            def on_complete(self, *args): pass
            def on_progress(self, *args): pass
            def on_processing_file(self, *args): pass
            def on_finish(self): pass
        
        callbacks = MemoryCallbacks()
        self.converter.procesar_carpeta(self.temp_dir, False, callbacks)
        
        # Verificar que la imagen fue convertida
        self.assertIn('huge.jpg', callbacks.converted)
        
        # Verificar que el PDF resultante existe y tiene un tamaÃ±o razonable
        pdf_path = os.path.join(self.temp_dir, 'huge.pdf')
        self.assertTrue(os.path.exists(pdf_path))
        pdf_size = os.path.getsize(pdf_path)
        original_size = os.path.getsize(huge_path)
        self.assertLess(pdf_size, original_size)  # El PDF debe ser mÃ¡s pequeÃ±o
    
    def test_formatos_imagen(self):
        """Prueba la conversiÃ³n de diferentes formatos de imagen"""
        # Crear un directorio temporal especÃ­fico para esta prueba
        test_dir = os.path.join(self.temp_dir, 'formatos_test')
        os.makedirs(test_dir)
        
        formatos = {
            'RGB': (255, 0, 0),
            'RGBA': (255, 0, 0, 128),
            'L': 128,
            'P': (255, 0, 0)
        }
        
        # Crear imÃ¡genes en diferentes formatos
        for formato, color in formatos.items():
            if formato == 'P':
                img = Image.new('RGB', (100, 100), color).convert('P')
            else:
                img = Image.new(formato, (100, 100), color)
            
            test_file = os.path.join(test_dir, f'test_{formato.lower()}.png')
            img.save(test_file)
            
            # Verificar que la imagen se creÃ³ correctamente
            self.assertTrue(os.path.exists(test_file), f"No se pudo crear la imagen {formato}")
        
        class FormatCallbacks:
            def __init__(self):
                self.converted = []
                self.errors = []
            def on_start(self): pass
            def on_images_found(self, total): pass
            def on_file_converted(self, name): 
                print(f"Convertido: {name}")
                self.converted.append(name)
            def on_file_error(self, name, error): 
                print(f"Error en {name}: {error}")
                self.errors.append((name, error))
            def on_complete(self, *args): pass
            def on_progress(self, *args): pass
            def on_processing_file(self, *args): pass
            def on_finish(self): pass
        
        callbacks = FormatCallbacks()
        self.converter.procesar_carpeta(test_dir, False, callbacks)
        
        # Verificar cada formato individualmente
        for formato in formatos:
            test_file = f'test_{formato.lower()}.png'
            self.assertIn(test_file, callbacks.converted, 
                         f"Fallo al convertir formato {formato}")
            
            # Verificar que el PDF se creÃ³ correctamente
            pdf_path = os.path.join(test_dir, f'test_{formato.lower()}.pdf')
            self.assertTrue(os.path.exists(pdf_path), 
                          f"No se creÃ³ el PDF para formato {formato}")
        
        # Verificar que no hubo errores
        if callbacks.errors:
            for nombre, error in callbacks.errors:
                print(f"Error inesperado en {nombre}: {error}")
        self.assertEqual(len(callbacks.errors), 0, 
                        "Se encontraron errores en la conversiÃ³n")
    
    def test_filtrado_patron(self):
        """Prueba el filtrado por patrÃ³n personalizado"""
        # Crear imÃ¡genes con diferentes nombres
        patrones = {
            'foto_1.jpg': 'RGB',
            'foto_2.png': 'RGB',
            'imagen_1.jpg': 'RGB',
            'imagen_2.png': 'RGB',
            'test.jpg': 'RGB'
        }
        
        # Crear las imÃ¡genes
        test_dir = os.path.join(self.temp_dir, 'patron_test')
        os.makedirs(test_dir)
        
        for nombre, modo in patrones.items():
            img = Image.new(modo, (100, 100), color='red')
            img.save(os.path.join(test_dir, nombre))
        
        class PatronCallbacks:
            def __init__(self):
                self.converted = []
            def on_start(self): pass
            def on_images_found(self, total): self.total = total
            def on_file_converted(self, name): self.converted.append(name)
            def on_file_error(self, name, error): pass
            def on_complete(self, *args): pass
            def on_progress(self, *args): pass
            def on_processing_file(self, *args): pass
            def on_finish(self): pass
        
        # Probar diferentes patrones
        pruebas = [
            ('foto_*.jpg', 1),    # Debe encontrar foto_1.jpg
            ('*.png', 2),         # Debe encontrar foto_2.png e imagen_2.png
            ('imagen_*.*', 2),    # Debe encontrar imagen_1.jpg e imagen_2.png
            ('test.*', 1),        # Debe encontrar test.jpg
            ('*.jpg', 3)          # Debe encontrar todos los .jpg
        ]
        
        for patron, esperados in pruebas:
            callbacks = PatronCallbacks()
            self.converter.procesar_carpeta(test_dir, False, callbacks, patron)
            self.assertEqual(
                len(callbacks.converted), 
                esperados, 
                f"PatrÃ³n '{patron}' encontrÃ³ {len(callbacks.converted)} archivos, esperaba {esperados}"
            )
    
    def test_extension_case(self):
        """Prueba que las extensiones son case-insensitive"""
        # Crear imÃ¡genes con extensiones en diferentes casos
        extensiones = ['.jpg', '.PNG']  # Solo dos extensiones diferentes
        test_dir = os.path.join(self.temp_dir, 'extension_test')
        os.makedirs(test_dir)
        
        # Crear dos archivos con nombres diferentes
        img = Image.new('RGB', (100, 100), color='red')
        img.save(os.path.join(test_dir, f'test1{extensiones[0]}'))  # test1.jpg
        img.save(os.path.join(test_dir, f'test2{extensiones[1]}'))  # test2.PNG
        
        class ExtCallbacks:
            def __init__(self):
                self.converted = []
            def on_start(self): pass
            def on_images_found(self, total): self.total = total
            def on_file_converted(self, name): self.converted.append(name)
            def on_file_error(self, name, error): pass
            def on_complete(self, *args): pass
            def on_progress(self, *args): pass
            def on_processing_file(self, *args): pass
            def on_finish(self): pass
        
        callbacks = ExtCallbacks()
        self.converter.procesar_carpeta(test_dir, False, callbacks)
        
        # DeberÃ­a encontrar las dos imÃ¡genes independientemente del caso
        self.assertEqual(len(callbacks.converted), len(extensiones))

```

## tests\test_main_window.py
```
"""
Unit tests for MainWindow folder creation functionality.
"""
import os
import tempfile
import pytest
import pandas as pd
from src.gui.main_window import MainWindow
from src.core.text_normalizer import TextNormalizer

@pytest.fixture
def main_window():
    """Create a MainWindow instance."""
    return MainWindow()

@pytest.fixture
def sample_excel():
    """Create a sample Excel file for testing."""
    with tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False) as tmp:
        # Create test DataFrame
        df = pd.DataFrame({
            'ID': ['1', '2', '3'],
            'NOMBRES': ['Juan', 'MarÃ­a', 'Pedro'],
            'APELLIDOS': ['PÃ©rez', 'GarcÃ­a', 'LÃ³pez']
        })
        df.to_excel(tmp.name, index=False)
        yield tmp.name
        os.unlink(tmp.name)

@pytest.fixture
def invalid_excel():
    """Create an invalid Excel file for testing."""
    with tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False) as tmp:
        # Create invalid DataFrame
        df = pd.DataFrame({
            'NOMBRE': ['Juan'],  # Incorrect column names
            'EDAD': [25]
        })
        df.to_excel(tmp.name, index=False)
        yield tmp.name
        os.unlink(tmp.name)

def test_load_template_with_valid_excel(main_window, sample_excel):
    """Test loading a valid Excel template."""
    with tempfile.TemporaryDirectory() as output_dir:
        # Simulate user interaction
        main_window.notebook.set_current_tab("Crear Carpetas")
        
        # Prepare mock methods
        details_text = []
        def mock_add_detail(text):
            details_text.append(text)
        main_window._add_folder_detail = mock_add_detail
        
        # Simulate loading template
        main_window._load_template()
        
        # Verify details were added
        assert len(details_text) > 0
        assert "Cargando plantilla" in details_text[0]

def test_normalize_folder_names(main_window):
    """Test folder name normalization."""
    normalizer = TextNormalizer()
    
    # Test cases
    test_cases = [
        ("JosÃ© Luis", "JOSE LUIS"),
        ("MarÃ­a GarcÃ­a", "MARIA GARCIA"),
        ("AÃ±o 2023", "ANO 2023"),
        ("Nombre con #caracteres especiales", "NOMBRE CON _CARACTERES ESPECIALES")
    ]
    
    for input_text, expected in test_cases:
        normalized = normalizer.normalize_text(input_text)
        assert normalized == expected

def test_folder_creation_from_excel(main_window, sample_excel):
    """Test creating folders from a valid Excel file."""
    with tempfile.TemporaryDirectory() as output_dir:
        # Simulate user interaction
        main_window.notebook.set_current_tab("Crear Carpetas")
        
        # Prepare mock methods
        details_text = []
        def mock_add_detail(text):
            details_text.append(text)
        main_window._add_folder_detail = mock_add_detail
        
        # Load Excel file
        df = pd.read_excel(sample_excel)
        
        # Manually trigger folder creation
        for _, row in df.iterrows():
            folder_name = main_window.text_normalizer.normalize_text(
                f"{row['ID']} - {row['NOMBRES']}"
            )
            
            if 'APELLIDOS' in df.columns and not pd.isna(row['APELLIDOS']):
                folder_name += f" {row['APELLIDOS']}"
            
            folder_path = os.path.join(output_dir, folder_name.upper())
            os.makedirs(folder_path, exist_ok=True)
        
        # Verify folders were created
        created_folders = os.listdir(output_dir)
        assert len(created_folders) == 3
        assert "1 - JUAN PEREZ" in created_folders
        assert "2 - MARIA GARCIA" in created_folders
        assert "3 - PEDRO LOPEZ" in created_folders

def test_handle_invalid_excel(main_window, invalid_excel):
    """Test handling of invalid Excel file."""
    with tempfile.TemporaryDirectory() as output_dir:
        # Simulate user interaction
        main_window.notebook.set_current_tab("Crear Carpetas")
        
        # Prepare mock methods for error handling
        error_messages = []
        def mock_show_error(title, message):
            error_messages.append(message)
        main_window.messagebox.showerror = mock_show_error
        
        # Try to load invalid Excel
        main_window._load_template()
        
        # Verify error was shown
        assert len(error_messages) > 0
        assert "columnas 'ID' y 'NOMBRES'" in error_messages[0]

```

## tests\test_image_processor.py
```
"""
Tests for the ImageProcessor class.
"""
import os
import tempfile
import pytest
from PIL import Image
from src.core.image_processor import ImageProcessor
import zipfile

@pytest.fixture
def image_processor():
    """Create an ImageProcessor instance."""
    return ImageProcessor()

@pytest.fixture
def sample_images():
    """Create multiple sample images for testing."""
    with tempfile.TemporaryDirectory() as tmp_dir:
        # Create test images
        img1 = Image.new('RGB', (100, 100), color='red')
        img1.save(os.path.join(tmp_dir, 'test1.png'))
        
        img2 = Image.new('RGB', (200, 200), color='blue')
        img2.save(os.path.join(tmp_dir, 'test2.jpg'))
        
        img3 = Image.new('RGB', (300, 300), color='green')
        img3.save(os.path.join(tmp_dir, 'test3.bmp'))
        
        yield tmp_dir

def test_get_image_files(image_processor, sample_images):
    """Test retrieving image files."""
    # Test all image files
    image_files = image_processor._get_image_files(sample_images, "*")
    assert len(image_files) == 3
    
    # Test with specific pattern
    image_files = image_processor._get_image_files(sample_images, "test1*")
    assert len(image_files) == 1
    assert "test1.png" in os.path.basename(image_files[0])

def test_convert_to_pdf(image_processor, sample_images):
    """Test converting a single image to PDF."""
    with tempfile.TemporaryDirectory() as output_dir:
        # Get first image from sample images
        image_files = image_processor._get_image_files(sample_images, "*")
        first_image = image_files[0]
        output_pdf = os.path.join(output_dir, "test_output.pdf")
        
        # Convert to PDF
        image_processor._convert_to_pdf(first_image, output_pdf)
        
        # Check PDF was created
        assert os.path.exists(output_pdf)
        assert os.path.getsize(output_pdf) > 0

def test_batch_convert_to_pdf(image_processor, sample_images):
    """Test batch PDF conversion."""
    with tempfile.TemporaryDirectory() as output_dir:
        output_file = os.path.join(output_dir, "batch_output.pdf")
        
        # Progress tracking
        progress_tracker = []
        def mock_progress_callback(current, total):
            progress_tracker.append((current, total))
        
        # Convert batch
        image_processor.batch_convert_to_pdf(
            sample_images, 
            output_file, 
            "*", 
            mock_progress_callback
        )
        
        # Check output
        assert os.path.exists(output_file)
        assert os.path.getsize(output_file) > 0
        
        # Check progress callback
        assert len(progress_tracker) > 0
        last_current, last_total = progress_tracker[-1]
        assert last_current == last_total

def test_cancel_processing(image_processor, sample_images):
    """Test cancellation of processing."""
    with tempfile.TemporaryDirectory() as output_dir:
        output_file = os.path.join(output_dir, "cancelled_output.pdf")
        
        # Start processing
        image_processor.batch_convert_to_pdf(
            sample_images, 
            output_file, 
            "*", 
            None
        )
        
        # Cancel processing
        image_processor.cancel_processing()
        
        # Check that processing can be interrupted
        with pytest.raises(InterruptedError):
            image_processor.batch_convert_to_pdf(
                sample_images, 
                output_file, 
                "*", 
                None
            )

def test_matches_pattern(image_processor):
    """Test pattern matching function."""
    assert image_processor._matches_pattern("test.jpg", "*")
    assert image_processor._matches_pattern("test.jpg", "*.jpg")
    assert image_processor._matches_pattern("test.jpg", "test*")
    assert not image_processor._matches_pattern("test.pdf", "*.jpg")

def test_batch_convert_to_pdf_preserve_structure(image_processor, sample_images):
    """Test preserving original directory structure when converting to PDF."""
    with tempfile.TemporaryDirectory() as output_dir:
        # Prepare output file paths
        pdf_output = os.path.join(output_dir, "output.pdf")
        zip_output = os.path.join(output_dir, "output.zip")
        
        # Convert to PDF
        image_processor.batch_convert_to_pdf(
            sample_images, 
            pdf_output, 
            "*", 
            None, 
            compress=False
        )
        
        # Verify PDF output
        assert os.path.exists(pdf_output)
        assert os.path.getsize(pdf_output) > 0
        
        # Verify filename includes original directory name
        assert "output" in os.path.basename(pdf_output)
        
        # Convert to ZIP
        image_processor.batch_convert_to_pdf(
            sample_images, 
            zip_output, 
            "*", 
            None, 
            compress=True
        )
        
        # Verify ZIP output
        assert os.path.exists(zip_output)
        assert os.path.getsize(zip_output) > 0
        
        # Verify filename includes original directory name
        assert "output" in os.path.basename(zip_output)
        
        # Extract and verify directory structure
        with zipfile.ZipFile(zip_output, 'r') as zf:
            # List all files in the ZIP
            zip_contents = zf.namelist()
            
            # Verify directory structure is preserved
            assert any("test1.png" in f for f in zip_contents)
            assert any("test2.jpg" in f for f in zip_contents)
            assert any("test3.bmp" in f for f in zip_contents)
            
            # Extract to verify structure
            with tempfile.TemporaryDirectory() as extract_dir:
                zf.extractall(extract_dir)
                
                # Verify subdirectories exist
                extracted_contents = os.listdir(extract_dir)
                assert len(extracted_contents) > 0
                
                # Verify PDF files are created with original image names
                pdf_files = [
                    f for f in os.listdir(os.path.join(extract_dir, extracted_contents[0])) 
                    if f.endswith('.pdf')
                ]
                assert len(pdf_files) == 3
                assert "test1.pdf" in pdf_files
                assert "test2.pdf" in pdf_files
                assert "test3.pdf" in pdf_files

```

## tests\test_imagen_a_pdf.py
```
import unittest
import os
import tempfile
import shutil
from PIL import Image
import zipfile
from imagen_a_pdf import ImagenAPdfApp
import customtkinter as ctk
import PyPDF2
from openpyxl import Workbook, load_workbook
import pandas as pd

class TestImagenAPdfApp(unittest.TestCase):
    def setUp(self):
        """ConfiguraciÃ³n inicial para cada prueba"""
        self.temp_dir = tempfile.mkdtemp()
        self.app = ImagenAPdfApp()
        
        # Crear algunas imÃ¡genes de prueba
        self.test_images = []
        for i in range(3):
            img_path = os.path.join(self.temp_dir, f'test_image_{i}.png')
            self.test_images.append(img_path)
            # Crear una imagen de prueba
            img = Image.new('RGB', (100, 100), color='red')
            img.save(img_path)
    
    def tearDown(self):
        """Limpieza despuÃ©s de cada prueba"""
        try:
            shutil.rmtree(self.temp_dir)
        except Exception as e:
            print(f"Error al limpiar directorio temporal: {e}")
    
    def test_creacion_ventana(self):
        """Prueba la creaciÃ³n de la ventana principal"""
        self.assertIsInstance(self.app.ventana, ctk.CTk)
        self.assertEqual(self.app.ventana.title(), "Herramientas de Productividad")
        
    def test_modo_comprimido_inicial(self):
        """Prueba el estado inicial del modo comprimido"""
        self.assertFalse(self.app.modo_comprimido.get())
    
    def test_conversion_individual(self):
        """Prueba la conversiÃ³n de una sola imagen"""
        img_path = self.test_images[0]
        pdf_path = os.path.splitext(img_path)[0] + '.pdf'
        
        # Simular conversiÃ³n
        with Image.open(img_path) as img:
            img = img.convert("RGB")
            img.save(pdf_path, "PDF")
        
        self.assertTrue(os.path.exists(pdf_path))
        # Verificar que el archivo existe y tiene un tamaÃ±o mayor a 0
        self.assertTrue(os.path.getsize(pdf_path) > 0)
    
    def test_creacion_zip(self):
        """Prueba la creaciÃ³n del archivo ZIP"""
        zip_path = os.path.join(self.temp_dir, 'test.zip')
        
        # Crear algunos PDFs de prueba
        pdf_files = []
        for img_path in self.test_images:
            pdf_path = os.path.splitext(img_path)[0] + '.pdf'
            with Image.open(img_path) as img:
                img = img.convert("RGB")
                img.save(pdf_path, "PDF")
            pdf_files.append(pdf_path)
        
        # Crear ZIP
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for pdf in pdf_files:
                zipf.write(pdf, os.path.basename(pdf))
        
        self.assertTrue(os.path.exists(zip_path))
        # Verificar contenido del ZIP
        with zipfile.ZipFile(zip_path, 'r') as zipf:
            self.assertEqual(len(zipf.namelist()), len(pdf_files))
    
    def test_manejo_errores_imagen_invalida(self):
        """Prueba el manejo de errores con una imagen invÃ¡lida"""
        invalid_img_path = os.path.join(self.temp_dir, 'invalid.png')
        with open(invalid_img_path, 'w') as f:
            f.write('not an image')
        
        # Intentar convertir imagen invÃ¡lida
        with self.assertRaises(Exception):
            Image.open(invalid_img_path)
    
    def test_estructura_directorios_zip(self):
        """Prueba la preservaciÃ³n de la estructura de directorios en ZIP"""
        # Crear estructura de directorios
        subdir = os.path.join(self.temp_dir, 'subdir')
        os.makedirs(subdir)
        
        # Crear imagen en subdirectorio
        img_path = os.path.join(subdir, 'test_sub.png')
        img = Image.new('RGB', (100, 100), color='blue')
        img.save(img_path)
        
        # Convertir a PDF
        pdf_path = os.path.splitext(img_path)[0] + '.pdf'
        with Image.open(img_path) as img:
            img = img.convert("RGB")
            img.save(pdf_path, "PDF")
        
        # Crear ZIP
        zip_path = os.path.join(self.temp_dir, 'test_structure.zip')
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            zipf.write(pdf_path, os.path.relpath(pdf_path, self.temp_dir))
        
        # Verificar estructura en ZIP
        with zipfile.ZipFile(zip_path, 'r') as zipf:
            self.assertIn('subdir/test_sub.pdf', zipf.namelist())

    def test_creacion_plantilla_excel(self):
        """Prueba la creaciÃ³n de la plantilla Excel"""
        plantilla_path = os.path.join(self.temp_dir, 'test_plantilla.xlsx')
        
        # Simular creaciÃ³n de plantilla
        wb = Workbook()
        ws = wb.active
        ws['A1'] = 'ID'
        ws['B1'] = 'NOMBRES'
        ws['C1'] = 'APELLIDOS'
        wb.save(plantilla_path)
        
        self.assertTrue(os.path.exists(plantilla_path))
        
        # Verificar estructura de la plantilla
        wb = load_workbook(plantilla_path)
        ws = wb.active
        self.assertEqual(ws['A1'].value, 'ID')
        self.assertEqual(ws['B1'].value, 'NOMBRES')
        self.assertEqual(ws['C1'].value, 'APELLIDOS')
    
    def test_creacion_carpetas_desde_excel(self):
        """Prueba la creaciÃ³n de carpetas desde datos Excel"""
        # Crear plantilla de prueba
        plantilla_path = os.path.join(self.temp_dir, 'test_datos.xlsx')
        wb = Workbook()
        ws = wb.active
        ws['A1'] = 'ID'
        ws['B1'] = 'NOMBRES'
        ws['C1'] = 'APELLIDOS'
        
        # Agregar datos de prueba
        datos = [
            ('1', 'Juan', 'PÃ©rez'),
            ('2', 'MarÃ­a', 'GarcÃ­a')
        ]
        for i, (id, nombre, apellido) in enumerate(datos, start=2):
            ws[f'A{i}'] = id
            ws[f'B{i}'] = nombre
            ws[f'C{i}'] = apellido
        wb.save(plantilla_path)
        
        # Directorio para las carpetas
        carpetas_dir = os.path.join(self.temp_dir, 'carpetas')
        os.makedirs(carpetas_dir)
        
        # Simular creaciÃ³n de carpetas
        df = pd.read_excel(plantilla_path)
        for _, row in df.iterrows():
            nombre_carpeta = f"{row['ID']} - {row['NOMBRES']} {row['APELLIDOS']}"
            ruta_carpeta = os.path.join(carpetas_dir, nombre_carpeta)
            os.makedirs(ruta_carpeta)
        
        # Verificar carpetas creadas
        carpetas_creadas = os.listdir(carpetas_dir)
        self.assertEqual(len(carpetas_creadas), 2)
        self.assertIn('1 - Juan PÃ©rez', carpetas_creadas)
        self.assertIn('2 - MarÃ­a GarcÃ­a', carpetas_creadas)

    def test_validacion_datos_excel(self):
        """Prueba la validaciÃ³n de datos en el Excel"""
        # Crear plantilla con columnas incorrectas
        plantilla_path = os.path.join(self.temp_dir, 'test_invalido.xlsx')
        wb = Workbook()
        ws = wb.active
        ws['A1'] = 'ID'
        ws['B1'] = 'NOMBRE'  # Columna incorrecta
        ws['C1'] = 'APELLIDO'  # Columna incorrecta
        wb.save(plantilla_path)
        
        # Verificar que se detectan columnas incorrectas
        df = pd.read_excel(plantilla_path)
        columnas_requeridas = ['ID', 'NOMBRES', 'APELLIDOS']
        columnas_validas = all(col in df.columns for col in columnas_requeridas)
        self.assertFalse(columnas_validas)

if __name__ == '__main__':
    unittest.main()

```

## tests\test_helpers.py
```
import unittest
import tkinter as tk
import os
import tempfile
from datetime import datetime
from src.utils.helpers import agregar_detalle, actualizar_progreso, generar_nombre_zip, validar_directorio

class TestHelpers(unittest.TestCase):
    def setUp(self):
        """ConfiguraciÃ³n inicial para cada prueba"""
        self.root = tk.Tk()
        self.text_widget = tk.Text(self.root)
        self.progress_bar = tk.ttk.Progressbar(self.root)
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Limpieza despuÃ©s de cada prueba"""
        self.root.destroy()
        if os.path.exists(self.temp_dir):
            for root, dirs, files in os.walk(self.temp_dir, topdown=False):
                for name in files:
                    os.remove(os.path.join(root, name))
                for name in dirs:
                    os.rmdir(os.path.join(root, name))
            os.rmdir(self.temp_dir)

    def test_agregar_detalle(self):
        """Prueba la funciÃ³n de agregar detalles"""
        # Probar diferentes tipos de mensajes
        tipos = {
            "info": "â„¹ï¸",
            "error": "âŒ",
            "success": "âœ…",
            "warning": "âš ï¸"
        }
        
        for tipo, prefijo in tipos.items():
            agregar_detalle(self.text_widget, f"Mensaje de {tipo}", tipo)
            contenido = self.text_widget.get("1.0", tk.END)
            self.assertIn(prefijo, contenido)
            self.assertIn(f"Mensaje de {tipo}", contenido)
            
        # Probar formato de timestamp
        agregar_detalle(self.text_widget, "Mensaje con timestamp")
        contenido = self.text_widget.get("1.0", tk.END)
        timestamp_format = r"\[\d{2}:\d{2}:\d{2}\]"
        self.assertRegex(contenido, timestamp_format)

    def test_actualizar_progreso(self):
        """Prueba la actualizaciÃ³n de la barra de progreso"""
        valores = [0, 0.5, 1]
        for valor in valores:
            actualizar_progreso(self.progress_bar, valor)
            self.assertEqual(self.progress_bar["value"], valor * 100)

    def test_generar_nombre_zip(self):
        """Prueba la generaciÃ³n de nombres ZIP"""
        nombre = generar_nombre_zip()
        otro_nombre = generar_nombre_zip()
        
        # Verificar formato bÃ¡sico
        self.assertTrue(nombre.startswith("PDFs_"))
        self.assertTrue(nombre.endswith(".zip"))
        
        # Verificar que los nombres son Ãºnicos
        self.assertNotEqual(nombre, otro_nombre)

    def test_validar_directorio(self):
        """Prueba la validaciÃ³n de directorios"""
        # Directorio vÃ¡lido
        valido, mensaje = validar_directorio(self.temp_dir)
        self.assertTrue(valido)
        self.assertEqual(mensaje, "")
        
        # Directorio que no existe
        no_existe = os.path.join(self.temp_dir, "no_existe")
        valido, mensaje = validar_directorio(no_existe)
        self.assertFalse(valido)
        self.assertEqual(mensaje, "El directorio no existe")
        
        # Archivo en lugar de directorio
        archivo = os.path.join(self.temp_dir, "archivo.txt")
        with open(archivo, "w") as f:
            f.write("test")
        valido, mensaje = validar_directorio(archivo)
        self.assertFalse(valido)
        self.assertEqual(mensaje, "La ruta no es un directorio")
        
        # Prueba de permisos (solo en sistemas Unix)
        if os.name != 'nt':
            dir_restringido = os.path.join(self.temp_dir, "restringido")
            os.makedirs(dir_restringido)
            os.chmod(dir_restringido, 0o000)
            valido, mensaje = validar_directorio(dir_restringido)
            self.assertFalse(valido)
            self.assertEqual(mensaje, "No hay permisos suficientes en el directorio")

```

## tests\test_folder_creator.py
```
"""
Pruebas unitarias para el mÃ³dulo FolderCreator.
"""
import os
import tempfile
import unittest
import pandas as pd

from src.core.folder_creator import FolderCreator

class TestFolderCreator(unittest.TestCase):
    """Pruebas para la creaciÃ³n de carpetas desde plantillas Excel."""
    
    def setUp(self):
        """ConfiguraciÃ³n inicial para cada prueba."""
        self.temp_dir = tempfile.mkdtemp()
        self.folder_creator = FolderCreator()
    
    def test_crear_plantilla(self):
        """Probar la creaciÃ³n de una plantilla Excel."""
        plantilla_path = os.path.join(self.temp_dir, 'plantilla_test.xlsx')
        
        # Crear plantilla
        exito, mensaje = self.folder_creator.crear_plantilla(plantilla_path)
        
        # Verificar
        self.assertTrue(exito)
        self.assertTrue(os.path.exists(plantilla_path))
        
        # Leer plantilla
        df = pd.read_excel(plantilla_path)
        
        # Verificar columnas
        columnas_esperadas = ['ID', 'NOMBRES', 'APELLIDOS']
        self.assertTrue(all(col in df.columns for col in columnas_esperadas))
    
    def test_procesar_plantilla_exitoso(self):
        """Probar procesamiento de plantilla Excel."""
        # Crear plantilla de prueba
        plantilla_path = os.path.join(self.temp_dir, 'plantilla_proceso.xlsx')
        df = pd.DataFrame({
            'ID': ['001', '002'],
            'NOMBRES': ['Juan', 'MarÃ­a'],
            'APELLIDOS': ['PÃ©rez', 'GarcÃ­a']
        })
        df.to_excel(plantilla_path, index=False)
        
        # Procesar plantilla
        exito, mensaje = self.folder_creator.procesar_plantilla(
            plantilla_path, 
            self.temp_dir
        )
        
        # Verificar
        self.assertTrue(exito)
        self.assertIn("Carpetas creadas: 2", mensaje)
        
        # Verificar carpetas creadas
        carpetas_esperadas = [
            '001 - JUAN PEREZ',
            '002 - MARIA GARCIA'
        ]
        for carpeta in carpetas_esperadas:
            ruta_carpeta = os.path.join(self.temp_dir, carpeta)
            self.assertTrue(os.path.exists(ruta_carpeta), f"No se creÃ³ la carpeta {carpeta}")
    
    def test_procesar_plantilla_con_callbacks(self):
        """Probar procesamiento de plantilla con callbacks."""
        class MockCallbacks:
            def __init__(self):
                self.carpetas_creadas = []
                self.carpetas_existentes = []
                self.errores = []
            
            def on_folder_created(self, nombre_carpeta):
                self.carpetas_creadas.append(nombre_carpeta)
            
            def on_folder_exists(self, nombre_carpeta):
                self.carpetas_existentes.append(nombre_carpeta)
            
            def on_folder_error(self, nombre_carpeta, error):
                self.errores.append((nombre_carpeta, error))
        
        # Crear plantilla de prueba
        plantilla_path = os.path.join(self.temp_dir, 'plantilla_callbacks.xlsx')
        df = pd.DataFrame({
            'ID': ['001', '002'],  # No duplicados
            'NOMBRES': ['Juan', 'MarÃ­a']
        })
        df.to_excel(plantilla_path, index=False)
        
        # Crear una carpeta existente
        os.makedirs(os.path.join(self.temp_dir, '001 - JUAN'), exist_ok=True)
        
        # Callbacks
        callbacks = MockCallbacks()
        
        # Procesar plantilla
        exito, mensaje = self.folder_creator.procesar_plantilla(
            plantilla_path, 
            self.temp_dir,
            callbacks
        )
        
        # Verificar
        self.assertTrue(exito)
        self.assertEqual(len(callbacks.carpetas_creadas), 2)  # Dos carpetas creadas
        self.assertEqual(len(callbacks.carpetas_existentes), 1)
        self.assertTrue('002 - MARIA' in callbacks.carpetas_creadas)
        self.assertEqual(callbacks.carpetas_existentes[0], '001 - JUAN')
    
    def test_procesar_plantilla_sin_columnas_requeridas(self):
        """Probar procesamiento de plantilla sin columnas requeridas."""
        # Crear plantilla sin columnas requeridas
        plantilla_path = os.path.join(self.temp_dir, 'plantilla_invalida.xlsx')
        df = pd.DataFrame({
            'COLUMNA_INVALIDA': ['Dato']
        })
        df.to_excel(plantilla_path, index=False)
        
        # Procesar plantilla
        exito, mensaje = self.folder_creator.procesar_plantilla(
            plantilla_path, 
            self.temp_dir
        )
        
        # Verificar
        self.assertFalse(exito)
        self.assertIn("Columna 'ID' no encontrada", mensaje)

if __name__ == '__main__':
    unittest.main()

```

## tests\Plantilla Nombres Carpetas.xlsx
```
PK     ! eß’ï¿½l  ï¿½   [Content_Types].xml ï¿½(ï¿½                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ï¿½ï¿½ï¿½nï¿½0Eï¿½ï¿½ï¿½ï¿½ï¿½Ubè¢ª*ï¿½>ï¿½-Rï¿½ï¿½ï¿½Xï¿½yï¿½ï¿½ï¿½ï¿½<Tï¿½Tï¿½&Vlï¿½=wF3M:ï¿½f+ï¿½)Ù°ï¿½Leï¿½2ï¿½}ï¿½ï¿½ï¿½Gï¿½aFï¿½ï¿½(ï¿½ï¿½MÆ·7ï¿½ï¿½ï¿½fmï¿½dMï¿½sï¿½ï¿½ï¿½ï¿½ï¿½Imï¿½ï¿½~ï¿½ï¿½;Q-ï¿½ï¿½ï¿½`ï¿½ï¿½+kï¿½ï¿½ï¿½ï¿½ï¿½Æ£ï¿½Å²ï¿½kGï¿½['Zdï¿½ï¿½ï¿½bdï¿½L8×ªJrï¿½WFQï¿½ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½l0ï¿½KXï¿½ï¿½ï¿½ttï¿½ï¿½ï¿½?&ï¿½ï¿½mjï¿½ï¿½ï¿½rz%!ï¿½
Ş…&ï¿½kï¿½ï¿½ï¿½Å·ï¿½ï¿½ï¿½HOfï¿½ï¿½Uï¿½VKMU+ï¿½yï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ï¿½s=ï¿½Oï¿½ï¿½ï¿½exe#1ï¿½$|ï¿½Gï¿½ï¿½ï¿½ï¿½[H2gï¿½6-ï¿½ËDÏ‘ï¿½A~Oï¿½tuï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½zë¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½ï¿½ï¿½Dï¿½Ø‹ï¿½ï¿½Mï¿½ {ï¿½<ï¿½Aï¿½   ï¿½ï¿½ PK     ! ï¿½ï¿½%S  ï¿½   _rels/.rels ï¿½(ï¿½                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ï¿½ï¿½ï¿½jï¿½ ï¿½ï¿½ï¿½ï¿½Aï¿½}cÚ1Fï¿½ŞŒAï¿½ï¿½ï¿½ï¿½TOIï¿½ï¿½5}ï¿½ï¿½`ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½xï¿½ï¿½
ï¿½E	ï¿½ï¿½bm\Wï¿½kï¿½:ï¿½#;ï¿½ï¿½H6ï¿½ï¿½ï¿½ï¿½ï¿½FLySì"ï¿½ï¿½XAï¿½ï¿½ï¿½2ï¿½ï¿½,Æ‚=ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½0tÒ£ï¿½#ï¿½*ï¿½;~f@=ï¿½[]Aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½--%Ô˜P*ï¿½ï¿½!ï¿½B2ï¿½.ï¿½ï¿½ï¿½Qï¿½@ï¿½zï¿½ï¿½ï¿½ï¿½jï¿½ï¿½Aï¿½Ë‚Rï¿½ï¿½;ï¿½f<Aï¿½Z+ï¿½ï¿½Í³ï¿½ï¿½ï¿½ï¿½ï¿½(zdï¿½ï¿½ï¿½Ò‰ï¿½yï¿½7iï¿½Ã°cÎ½ï¿½ï¿½%-4%rï¿½ï¿½ï¿½vï¿½ï¿½ï¿½"9ï¿½ï¿½ï¿½;   ï¿½ï¿½ PK     ! V%ï¿½ï¿½#       xl/workbook.xmlï¿½Uï¿½Oï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½P6ï¿½ï¿½lCN5ï¿½ï¿½ï¿½.11tï¿½'Pï¿½ï¿½1ï¿½ï¿½ï¿½
c:wï¿½ï¿½l-ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½:Kï¿½#ï¿½%ï¿½ ï¿½=#ï¿½G"ï¿½ï¿½bï¿½ï¿½OCï¿½ï¿½Qï¿½hï¿½Tï¿½lï¿½ï¿½Xï¿½ï¿½ï¿½ï¿½~9\
ï¿½0ï¿½@^pï¿½Tï¿½f%,ï¿½ï¿½(Xï¿½ï¿½ï¿½U0ï¿½ï¿½,$ï¿½qï¿½0ï¿½ï¿½Ô´-ï¿½33ï¿½sï¿½"ï¿½r1ï¿½ï¿½"ï¿½2ï¿½ï¿½Dï¿½ï¿½*ï¿½_&ï¿½(;ï¿½,ï¿½.ï¿½ï¿½*ï¿½Hd@ï¿½xï¿½ï¿½Sï¿½Qï¿½gï¿½\H:K!ìš¸ï¿½ï¿½ï¿½ï¿½ï¿½O,hï¿½n'0mmï¿½ï¿½Hï¿½Rï¿½ï¿½@ï¿½-ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½z;ï¿½!9ï¿½dï¿½\ï¿½pï¿½Jzdå­±ï¿½W0b}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½kn6>:ï¿½ï¿½İ´ï¿½Eï¿½(.iï¿½+ï¿½bï¿½ï¿½Rï¿½ï¿½\ï¿½xï¿½{0Kï¿½1!ï¿½bTï¿½ï¿½vß¶{ï¿½<Zï¿½y"a ï¿½ï¿½ï¿½Éœ*6ï¿½ï¿½ï¿½ï¿½VVï¿½8 btï¿½~W\28; !Zï¿½tVNï¿½JP%ï¿½ï¿½ï¿½o\ï¿½ï¿½jï¿½&Rï¿½bï¿½*ï¿½xF,ï¿½ï¿½"ï¿½ï±šİ½ï¿½!ï¿½ï¿½(ï¿½F:&ï¿½lï¿½ï¿½'xJï¿½Sï¿½DIï¿½gï¿½9dï¿½ï¿½>Bï¿½ï¿½ï¿½ï¿½ï¿½xï¿½Aï¿½ï¿½ï¿½}Iï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½Cï¿½q\ï¿½ï¿½ï¿½1ï¿½[}ï¿½ï¿½}ï¿½ï¿½HÏï¿½Tï¿½*ï¿½ï¿½`ï¿½eï¿½ï¿½ug!ï¿½_ï¿½ï¿½ï¿½Æ³ï¿½zİ¿k:Û‹X_b7ï¿½-ï¿½Wï¿½!ï¿½oyï¿½%ï¿½@lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½oyï¿½Pï¿½,ï¿½ï¿½ï¿½;e|ï¿½ cB\Aï¿½ï¿½ o0
ZF!<ï¿½n6ï¿½o(5ï¿½%Pkzï¿½7ï¿½ï¿½W(ï¿½{Yï¿½Mï¿½1ï¿½ï¿½ï¿½Cï¿½Å¤)bï¿½,ï¿½i4ï¿½Hwï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ju^ï¿½ï¿½ï¿½qï¿½7rï¿½#kï¿½ï¿½6ï¿½ï¿½@}Èeï¿½Fï¿½cï¿½Aï¿½ï¿½ï¿½H0>qC]}ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½ï¿½f5ï¿½ï¿½ï¿½kï¿½7c_ï¿½ï¿½jv=9o'Vï¿½oï¿½Ù¿
t(ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½Yï¿½vtovt_^L/vï¿½=?ï¿½ï¿½ß†ï¿½:/Fï¿½pwï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½×„ï¿½Ps8ï¿½]ï¿½ï¿½ï¿½~ï¿½  ï¿½ï¿½ PK     ! ï¿½>ï¿½ï¿½ï¿½   ï¿½   xl/_rels/workbook.xml.rels ï¿½(ï¿½                                                                                                                                                                                                                                                                 ï¿½RMKï¿½0ï¿½ï¿½ï¿½0wï¿½vï¿½t/"ï¿½Uï¿½É´)ï¿½&!3~ï¿½ï¿½*ï¿½]Xï¿½K/oï¿½yï¿½ï¿½ï¿½vï¿½5ï¿½ï¿½ï¿½+ï¿½ï¿½zlï¿½;oï¿½ï¿½ï¿½bï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½sï¿½>ï¿½ï¿½,ï¿½8ï¿½ï¿½(%ï¿½ï¿½ï¿½"Dï¿½ï¿½Ò†4jï¿½0u2jsï¿½ï¿½MYï¿½Ë´ï¿½ï¿½ï¿½Sì­‚ï¿½ï¿½ï¿½ ï¿½)fï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½yï¿½ï¿½	I<y ï¿½ï¿½ï¿½!+ï¿½ï¿½Eï¿½ï¿½ï¿½fMyï¿½kï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½5=|ï¿½t ï¿½ï¿½G)ï¿½så¢™ï¿½Uï¿½ï¿½tBï¿½ï¿½)ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½   ï¿½ï¿½ PK     ! O)ï¿½ï¿½  _     xl/worksheets/sheet1.xmlï¿½ï¿½ï¿½nï¿½0ï¿½ï¿½Wï¿½;Xï¿½ï¿½FRï¿½REï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½íœ´ï¿½wï¿½ï¿½)ï¿½Rnï¿½"0flï¿½ï¿½ï¿½x>iEà¼´ï¿½ï¿½Yï¿½RFï¿½Zï¿½mIï¿½\O>Sï¿½75Wï¿½@Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½hï¿½Î· ï¿½ ï¿½ï¿½ï¿½ï¿½!tc^ï¿½ï¿½ï¿½OlGï¿½4ï¿½ï¿½ï¿½wxiï¿½ï¿½4ï¿½1Í¥ï¿½Bï¿½ï¿½aØ¦ï¿½^ï¿½ï¿½k0ï¿½qï¿½xï¿½ï¿½}+;?Ğ´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½CD%ï¿½ï¿½ï¿½Dï¿½bï¿½5ï¿½ï¿½Jaİ§lï¿½99ï¿½s|ï¿½ï¿½Qï¿½R8ï¿½m$ï¿½KÎ·ï¿½ï¿½Ùœq1ï¿½nï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½ï¿½?ï¿½Rï¿½4ï¿½ï¿½+ï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½ï¿½ï¿½cï¿½ï¿½rQKï¿½ï¿½*ï¿½)é—¬Xï¿½([.ï¿½~K8ï¿½w}xï¿½ï¿½ ï¿½ï¿½Qï¿½Û³ï¿½vï¿½Oï¿½`(Eï¿½ï¿½z"A`Jï¿½t3Gï¿½ï¿½Fï¿½ ï¿½ï¿½ï¿½u4ï¿½7G*ï¿½aeï¿½Yï¿½%ï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½<É¦ï¿½,ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½6ï¿½ï¿½Fï¿½ï¿½ï¿½ï¿½@7cï¿½	Nï¿½ï¿½Uï¿½ï¿½-Ñ²?ï¿½ï¿½F~ï¿½ï¿½ï¿½&ï¿½ï¿½
|Xï¿½Eï¿½ï¿½ï¿½`ï¿½ï¿½Kï¿½"2ï¿½  ï¿½ï¿½   ï¿½ï¿½ï¿½ï¿½Kï¿½ Eï¿½bX@ï¿½ï¿½ï¿½4ï¿½ï¿½BI:ï¿½M1ï¿½ï¿½}ï¿½Dufï¿½<y\ï¿½ï¿½i=ï¿½rï¿½ï¿½xï¿½_Ù³Eeï¿½!'_Mï¿½ï¿½7ï¿½R5ï¿½Ï¨ï¿½ï¿½ï¿½ï¿½"rbê„²ï¿½ï¿½ï¿½nVï¿½ï¿½ï¿½tï¿½ï¿½o	ï¿½&ï¿½-ï¿½<ï¿½AÊ›ï¿½#fï¿½ï¿½Pï¿½kB+ï¿½Î‰ï¿½ï¿½ï¿½D(ï¿½ï¿½ï¿½
ï¿½ï¿½!ï¿½^%ï¿½ï¿½Sï¿½Dï¿½Hï¿½Yï¿½/ï¿½ï¿½H ï¿½ï¿½U%qV'qï¿½ï¿½ï¿½ï¿½âˆ‡ï¿½[ï¿½ï¿½ï¿½ï¿½vï¿½ï¿½ï¿½4ï¿½Ó°
Cï¿½VBï¿½![!ï¿½umï¿½ï¿½M|  ï¿½ï¿½   ï¿½ï¿½ï¿½)HLOï¿½M,Jï¿½ï¿½+Vï¿½IM+ï¿½U2ï¿½37UR(ï¿½LÏ€sJï¿½lï¿½ï¿½ï¿½ï¿½KJï¿½sï¿½ÌŒï¿½Ä”ï¿½"ï¿½jï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½Fï¿½<ï¿½(ï¿½8#5ï¿½ï¿½   ï¿½ï¿½ PK     ! ï¿½%ï¿½f  S     xl/theme/theme1.xmlï¿½Yï¿½n7ï¿½ï¿½;{O,Ù’bï¿½Kï¿½ï¿½6qbï¿½Jï¿½ï¿½]jï¿½wï¿½ );ï¿½É±@ï¿½ï¿½iï¿½Kï¿½ï¿½z(ï¿½Hï¿½^Ò§qï¿½ï¿½Mï¿½ï¿½Bï¿½ï¿½JZZTl'ï¿½l-ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½zï¿½Aï¿½ï¿½!ï¿½ï¿½T/WDï¿½ï¿½G4ï¿½[ï¿½ï¿½~ï¿½ï¿½zï¿½ï¿½ï¿½Yï¿½ï¿½H+ï¿½\ï¿½|ï¿½ï¿½ï¿½xC%$%ï¿½grï¿½ï¿½Dï¿½|ceEï¿½ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Gï¿½Dİ”ï¿½ï¿½V*ï¿½ï¿½ï¿½,@Nï¿½ï¿½ï¿½á†ï¿½5ï¿½`sJï¿½ï¿½ï¿½1SR/ï¿½Lhï¿½ï¿½ï¿½aï¿½Ñ¨ï¿½r";Lï¿½Cï¿½Zï¿½ï¿½ï¿½Qï¿½<PbX*xï¿½
*ï¿½ï¿½l^]ï¿½ï¿½&ï¿½ï¿½ï¿½-ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½VOfLï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½vï¿½ï¿½nuFï¿½ pï¿½ï¿½Vï¿½2ï¿½Zoï¿½Úï¿½,ï¿½ï¿½ï¿½EÚJï¿½Rsï¿½%ï¿½k27ï¿½ï¿½vï¿½Yï¿½bï¿½ï¿½ï¿½Z[ï¿½ï¿½Wï¿½ï¿½Uo@__ï¿½ï¿½ï¿½[ï¿½Nï¿½ï¿½ï¿½ï¿½7ï¿½+ï¿½Fï¿½ï¿½Pï¿½h6Z@kï¿½ï¿½zï¿½dï¿½Ùï¿½ï¿½ï¿½Jï¿½ï¿½ fÑ¥Yyï¿½ï¿½ï¿½Zï¿½ï¿½sï¿½ï¿½2ï¿½hï¿½ï¿½$'CBwp:kxï¿½ï¿½ï¿½ï¿½Ê…%ï¿½ï¿½Pï¿½\ï¿½ï¿½s1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?Eï¿½ï¿½?9~ï¿½ï¿½ï¿½ï¿½OÇ?ï¿½ï¿½ï¿½r6ï¿½ï¿½,.o|ï¿½ï¿½g~ï¿½1ï¿½ï¿½ï¿½7/ï¿½ï¿½ï¿½2ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½@È ï¿½D/ï¿½|ï¿½Û³'/ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½[ï¿½ï¿½>Mï¿½Dï¿½ï¿½ï¿½ï¿½)ï¿½fï¿½JNï¿½|;ï¿½	ï¿½ï¿½ï¿½ mï¿½Jï¿½	f>\ï¿½ï¿½Æ»+ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½Y1Vï¿½ï¿½ï¿½Fï¿½:ï¿½]ï¿½Yï¿½ï¿½nh^%ï¿½ï¿½Yï¿½g.ï¿½eï¿½>Æ‡>ï¿½ï¿½9ï¿½ï¿½sï¿½ï¿½Ó tlï¿½Iï¿½#ï¿½Ã™ï¿½1ÉˆBï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]wi(ï¿½ï¿½Cï¿½ï¿½Qï¿½ï¿½ï¿½kï¿½>8ï¿½4ß´CSï¿½ï¿½Ä§3ï¿½Ú±ï¿½ï¿½]ï¿½ï¿½Ì§ï¿½69tï¿½ï¿½ï¿½yï¿½ï¿½ï¿½ï¿½:+ï¿½ï¿½Hï¿½qï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½`"ï¿½2ï¿½+x:&ï¿½ï¿½nDï¿½ï¿½ï¿½ï¿½-@ß’ï¿½o`ï¿½W^ï¿½ï¿½Iï¿½"ï¿½ï¿½#Í›ï¿½ï¿½2rï¿½ï¿½:	Nsï¿½ï¿½4Kï¿½ï¿½ï¿½Bï¿½=ï¿½|ï¿½]ï¿½fï¿½~?ï¿½lï¿½ï¿½ï¿½Rï¿½ï¿½ï¿½Bpï¿½ÆHï¿½ ï¿½oÆ¢ï¿½ï¿½Nï¿½Miï¿½ï¿½bï¿½(Tï¿½wï¿½xz:mï¿½ï¿½ï¿½Kï¿½ï¿½%xï¿½_Xxï¿½ï¿½8ï¿½#ï¿½Ï»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½Zmï¿½ï¿½ï¿½y_lï¿½ï¿½tiï¿½<ï¿½ï¿½ï¿½	#7ï¿½ï¿½%QMoï¿½ï¿½ï¿½Ğ”'ï¿½(ï¿½.ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½Jï¿½Cï¿½]5#_,Ò±D9ï¿½0Û™e3|ï¿½ï¿½ï¿½8Iï¿½ï¿½6ï¿½a]ï¿½ï¿½Hï¿½vydï¿½ï¿½Ê³áŒŒï¿½c3Nï¿½igeï¿½vï¿½ï¿½Uï¿½TKï¿½ï¿½V5ï¿½ï¿½Rï¿½6S|ï¿½ï¿½,Î¬	]ï¿½ï¿½ï¿½Ü€]ï¿½ï¿½	f$ï¿½vï¿½sï¿½ï¿½-ï¿½ï¿½ï¿½ï¿½H&8"ï¿½ï¿½ï¿½Ş‹>ï¿½'MceFï¿½9ï¿½ï¿½ï¿½55Ù·ï¿½v'ï¿½ï¿½Õ–ï¿½ï¿½zï¿½mï¿½4nï¿½^ï¿½y{"YVNNï¿½ï¿½ï¿½VĞ¬ï¿½ï¿½ï¿½aï¿½ï¿½ï¿½i^ï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½P	ï¿½ï¿½&ï¿½	×¹7ï¿½ï¿½ï¿½ï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½NÈ…Tï¿½X&64Ì«"Xfï¿½p#ï¿½jï¿½zQ
ï¿½H)ï¿½ï¿½!ï¿½6)ï¿½ï¿½ï¿½kï¿½pHBUvviï¿½ï¿½Q@QJï¿½Xqï¿½DGhï¿½ï¿½bï¿½ï¿½uï¿½ï¿½>ï¿½p;a*ï¿½~ï¿½ï¿½4mmï¿½ï¿½-ï¿½EÒ•/ï¿½Î®cï¿½'ï¿½(ï¿½:Eï¿½ï¿½lï¿½&ï¿½g2ï¿½'+ï¿½tï¿½ï¿½nï¿½;ï¿½*&ï¿½/Hï¿½rï¿½ï¿½Tï¿½ï¿½	\ï¿½Eï¿½!ï¿½ï¿½
ï¿½tï¿½ï¿½.TÂ¡
ï¿½	{.ï¿½Lï¿½hï¿½ï¿½XxAï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½9KÃ¤5L}jï¿½ï¿½HP8ï¿½T"Ùƒï¿½dï¿½ï¿½bï¿½ï¿½ï¿½$YAï¿½DTI\ï¿½[ï¿½ä°ï¿½ï¿½ï¿½}ï¿½(ï¿½P7Õ¤(w2ï¿½ï¿½ï¿½"ï¿½ï¿½nrï¿½ï¿½ï¿½ï¿½Mï¿½ï¿½ï¿½;ï¿½-ï¿½ï¿½ï¿½^ï¿½V*ï¿½ï¿½ï¿½ï¿½ï¿½=ï¿½LO5+ï¿½9ï¿½ï¿½yï¿½ÚŠï¿½ï¿½ï¿½jï¿½ï¿½Gmï¿½>Hï¿½ï¿½óŠï¿½'ï¿½ï¿½ï¿½ï¿½P[ï¿½ï¿½`ï¿½+Q}ï¿½6HH[ï¿½8ï¿½ELï¿½ï¿½mXï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½.:ï¿½_ï¿½ï¿½7ï¿½tï¿½iï¿½Ysï¿½srï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]XØ±uï¿½ï¿½ï¿½ï¿½ï¿½ï¿½dï¿½ï¿½ï¿½h:ï¿½Ç˜_ï¿½ï¿½?<ï¿½ï¿½}pï¿½6\ñ™’ï¿½jï¿½\ï¿½ï¿½ï¿½a$ï¿½ï¿½ï¿½5[7ï¿½  ï¿½ï¿½ PK     ! !ï¿½Ã°5  ï¿½     xl/styles.xmlï¿½V]oï¿½0}Gï¿½?X~Ïœï¿½Miï¿½$ï¿½ï¿½ï¿½4	Ò†Ä«ï¿½8ï¿½ï¿½?"ï¿½ï¿½ï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½14ï¿½ï¿½jï¿½\ï¿½{ï¿½ï¿½ï¿½ï¿½}+ï¿½cï¿½ï¿½Z%8ï¿½ï¿½1b*ï¿½Wï¿½ï¿½Í¼%Fï¿½ï¿½ï¿½ï¿½B+ï¿½ï¿½#ï¿½ï¿½ï¿½ï¿½í›¸ï¿½Gï¿½nï¿½Yï¿½Nï¿½ï¿½ï¿½jMHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½6ï¿½Zï¿½ï¿½=ï¿½+ï¿½hQï¿½ERï¿½ï¿½ï¿½DRï¿½pï¿½ï¿½ï¿½ï¿½ß€Hjï¿½7ï¿½ï¿½kYQï¿½w\p{ï¿½0ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½;Tï¿½`Nsï¿½ï¿½ÖŒï¿½tï¿½Gï¿½Hï¿½]ï¿½ï¿½^ .ï¿½eï¿½sï¿½ï¿½îŠ¬ï¿½ï¿½Hï¿½ï¿½:ï¿½ "~ï¿½ï¿½ï¿½Ö¼iNï¿½ï¿½ï¿½>ï¿½Æ¥Vï¿½Fï¿½nï¿½Mï¿½ï¿½:	ï¿½ß•ï¿½ï¿½2ï¿½	ï¿½Ò¸ï¿½GwT@$ï¿½$ï¿½s-ï¿½Aï¿½åºˆï¿½ï¿½ï¿½ï¿½Tï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½c]ï¿½s{È“ï¿½wAï¿½xï¿½lï¿½xï¿½ï¿½ï¿½wï¿½@ï¿½G ï¿½ï¿½pï¿½eÄ¹'Cï¿½ï¿½Î›eFe0Aï¿½ï¿½ï¿½Xï¿½^
Zï¿½ï¿½ï¿½ï¿½{!{oï¿½1ï¿½ï¿½ï¿½mRiS@+ï¿½ï¿½ï¿½ï¿½PVZï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Z]ï¿½ßï¿½ï¿½kï¿½îµ¢ï¿½i?ï¿½ï¿½ï¿½ï¿½ï¿½nMï¿½=@ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½s;ï¿½Sï¿½ï¿½ï¿½ï¿½ï¿½Ü¾ï¿½ï¿½kï¿½kr&Ä+ï¿½[yï¿½Éï¿½Dï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½s'pï¿½)Ã°×¤ï¿½8ï¿½ï¿½h=ï¿½vï¿½*XÔ–'ï¿½ï¿½Hï¿½ï¿½)RW#ZUï¿½ï¿½ï¿½Yï¿½ï¿½6ï¿½ï¿½8ï¿½?ï¿½Wï¿½ï¿½)i]ï¿½Oï¿½A~K]{ï¿½ï¿½ï¿½ï¿½wï¿½å¹‹ï¿½)ï¿½ï¿½kï¿½ï¿½eï¿½aï¿½>ï¿½pTï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½] 	ï¿½ï¿½^1ï¿½5\Xï¿½ï¿½ï¿½0ï¿½ï¿½lï¿½ï¿½ï¿½[wï¿½wGï¿½ï¿½+XIaoO|boï¿½ï¿½ï¿½ï¿½ï¿½iï¿½A$ï¿½<ï¿½ï¿½z,Xï¿½=Xk?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½jï¿½nï¿½ï¿½ï¿½Boï¿½oï¿½ï¿½|ï¿½"omï¿½^4ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½^ï¿½ï¿½iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ø¡Ä›s,ï¿½ï¿½IOï¿½shOï¿½ï¿½Â…ï¿½!
|/ï¿½ï¿½ï¿½7_Ğ¥ï¿½\ï¿½"/ï¿½ï¿½pï¿½ï¿½oï¿½ï¿½,ï¿½pï¿½^ï¿½"ï¿½$ï¿½ï¿½Í‘ï¿½Ö–K&ï¿½ï¿½ï¿½Fï¿½$ï¿½ï¿½ï¿½2:Aï¿½ï¿½wï¿½ï¿½  ï¿½ï¿½ PK     ! hiï¿½  ï¿½     xl/sharedStrings.xmllï¿½Akï¿½@ï¿½ï¿½ï¿½ï¿½aï¿½uï¿½K)I$ï¿½ï¿½fKï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½}ï¿½f3ï¿½ï¿½Ë¶pAï¿½ï¿½Q.ï¿½Q" iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½nï¿½/8hï¿½ï¿½ï¿½ï¿½ï¿½,&ï¿½ï¿½]ï¿½ zï¿½sq
ï¿½ï¿½*%ï¿½Nh5ï¿½ï¿½)ï¿½ï¿½ï¿½Vï¿½Xï¿½ï¿½ï¿½Gï¿½ï¿½bï¿½ï¿½|Lï¿½giï¿½!;ï¿½Qï¿½{ï¿½td>;ï¿½ï¿½
EÆ¦ï¿½Bï¿½ï¿½e2ï¿½ï¿½ï¿½nJï¿½VoMï¿½ï¿½ï¿½ï¿½{ï¿½\.fj ï¿½ï¿½ï¿½ï¿½USï¿½ï¿½Lï¿½]+ï¿½Tï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½Ó¶3ï¿½/ï¿½ï¿½ï¿½:ï¿½ï¿½ï¿½:
ï¿½ï¿½4Mï¿½ï¿½ï¿½hï¿½ï¿½bï¿½foc`Z6ï¿½ï¿½1pAï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½*ï¿½  ï¿½ï¿½ PK     ! ï¿½ï¿½ï¿½  jï¿½     docProps/thumbnail.wmfÌOl#ï¿½}Å‡ï¿½Kqï¿½\ï¿½ï¿½ï¿½(qï¿½lÓ€ï¿½ï¿½ï¿½ï¿½qâ„²ï¿½kï¿½ì¥²ï¿½Iï¿½4ï¿½PKzSÛ‹ï¿½Iï¿½ï¿½R(zï¿½Päš“ï¿½ï¿½"W*9ï¿½Xï¿½ï¿½ï¿½ï¿½zï¿½ï¿½')ï¿½ï¿½rJlï¿½ï¿½;ï¿½ï¿½Jï¿½&ï¿½ï¿½ï¿½G3ï¿½ï¿½ï¿½qï¿½ï¿½ï¿½3ï¿½ï¿½$ï¿½ï¿½ï¿½_'ï¿½ï¿½ï¿½	
ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½syï¿½ï¿½*ï¿½wï¿½;ï¿½9ï¿½?ï¿½9ï¿½ï¿½{ï¿½Nzï¿½'ï¿½ï¿½ï¿½ï¿½ä¬±~eï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ß¿ï¿½Fï¿½ï¿½ßšï¿½ß¾ï¿½Ì½Nï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½H.]ï¿½ï¿½dï¿½ï¿½ï¿½ï¿½{ï¿½l}ï¿½\Ş¾ï¿½ï¿½ï¿½aï¿½Bï¿½|Rï¿½ï¿½ï¿½Ù¼ï¿½2ï¿½ï¿½H.gï¿½ï¿½ï¿½ï¿½ï¿½l:ï¿½#ï¿½ï¿½ï¿½}Jï¿½tï¿½lï¿½bï¿½ï¿½51rï¿½ï¿½ï¿½ÃŸï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½O'[9gc=ï¿½gï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½Qï¿½×“Oï¿½ï¿½ï¿½G.ï¿½Wï¿½cï¿½yï¿½$=ï¿½ï¿½ï¿½_$ï§ï¿½Bï¿½Å’Ùºï¿½ï¿½.ï¿½8ngï¿½ï¿½YNï¿½=:Bï¿½Zï¿½tï¿½Óµï¿½&ï¿½G}tï¿½gï¿½ï¿½ï¿½/%UMï¿½ï¿½K]ï¿½ï¿½E9ï¿½&ó¤¤³ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ Baï¿½ï¿½&ï¿½O|ï¿½'fï¿½"@ï¿½3ï¿½}ï¿½O~~qNhï¿½'~ï¿½ï¿½Ä‚ï¿½:4ï¿½ï¿½ï¿½SOï¿½ Bï¿½V4ï¿½}ï¿½3ï¿½<;ï¿½Xï¿½Yï¿½'>ï¿½ÜµÄ³"@+ï¿½ï¿½>ï¿½ÚµgK"@ï¿½7ï¿½}â—¾ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½Oï¿½ï¿½_ï¿½A,ï¿½ ï¿½	ï¿½_~ï¿½=ï¿½xNhï¿½'ï¿½ï¿½7f+"@;oï¿½ï¿½Ä¯|ï¿½ï¿½ï¿½ï¿½"@ï¿½ï¿½ï¿½>ï¿½ï¿½Í¿ï¿½Aï¿½ï¿½ ï¿½	ï¿½ï¿½ï¿½Õ¿ï¿½Aï¿½ ï¿½ï¿½	ï¿½ï¿½ï¿½ï¿½oï¿½ ï¿½Dï¿½vÑ„ï¿½ï¿½ï¿½ï¿½ï¿½wf/ï¿½ mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½VgqAhï¿½Lxï¿½ï¿½ï¿½ï¿½tg/ï¿½ -ï¿½ï¿½>ï¿½rï¿½Tï¿½ï¿½w_ï¿½ALï¿½ï¿½ï¿½\ï¿½ï¿½xK=ï¿½ï¿½ï¿½ï¿½0ï¿½Ú¢	ï¿½ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½>fï¿½ï¿½ï¿½ï¿½}ï¿½g?&ï¿½%ï¿½'ï¿½ï¿½ï¿½ï¿½3ï¿½K"@ï¿½ï¿½	:1ï¿½|ï¿½sM}$Wï¿½ï¿½ï¿½nï¿½ï¿½vï¿½ï¿½Ö´ï¿½ï¿½Gï¿½fï¿½K4ï¿½ï¿½1/Tï¿½ï¿½DSï¿½e%>ï¿½ï¿½Dï¿½K4ï¿½Vï¿½ Toï¿½.aYï¿½ï¿½ï¿½>ï¿½ï¿½Mï¿½E,ï¿½ï¿½Rï¿½ï¿½ï¿½ï¿½Qï¿½6Oï¿½<ï¿½K4EZVï¿½#ï¿½ï¿½ï¿½^ï¿½hï¿½$bI4ï¿½ï¿½8z]ï¿½)Ò²ï¿½}ï¿½ï¿½%ï¿½F+ï¿½Xï¿½ï¿½ï¿½^ï¿½hï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½*"VDï¿½ï¿½mï¿½ï¿½%ï¿½"-+ï¿½ï¿½'z]ï¿½iï¿½ï¿½ï¿½UÑ zï¿½ï¿½uï¿½ï¿½Hï¿½J|ï¿½ï¿½ï¿½^ï¿½hï¿½&bM4ï¿½ï¿½6z]ï¿½)Ò²ï¿½}ï¿½ï¿½%ï¿½F[qA4ï¿½ï¿½6z]ï¿½)Ò²Rï¿½}ï¿½ï¿½%ï¿½Fï¿½ï¿½Xjï¿½K4EZVï¿½#ï¿½Oï¿½ï¿½Dï¿½hï¿½".ï¿½ï¿½ï¿½Fï¿½K4EZVï¿½#ï¿½Oï¿½ï¿½Dï¿½hK".ï¿½ï¿½ï¿½Fï¿½K4EZVï¿½@ï¿½Ó‰ï¿½Kï¿½ï¿½%>Â·ï¿½]ï¿½eï¿½ï¿½ï¿½yÑ Fï¿½DKï¿½%>ï¿½ï¿½Dï¿½Kï¿½ï¿½Vï¿½ ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ÑŠ"EKï¿½ï¿½.ï¿½iEï¿½ï¿½ï¿½ï¿½6z]ï¿½eï¿½ï¿½ï¿½%Ñ Fï¿½DKï¿½%>ï¿½ï¿½Dï¿½Kï¿½ï¿½Vï¿½,ï¿½hï¿½hï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½*"VDï¿½ï¿½-ï¿½Vï¿½ï¿½ï¿½ï¿½.ï¿½2ZUÄªhPï¿½]ï¿½%ÒŠï¿½}ï¿½ï¿½%ZFï¿½ï¿½Xjï¿½Kï¿½DZQï¿½#ï¿½Oï¿½ï¿½Dï¿½h".ï¿½5ï¿½%Z"ï¿½(ï¿½ï¿½'z]ï¿½eï¿½ï¿½ï¿½uÑ Fï¿½DKï¿½%>ï¿½ï¿½Dï¿½Kï¿½ï¿½ï¿½(ï¿½hPï¿½]ï¿½%ÒŠï¿½}ï¿½ï¿½%ZF[qI4ï¿½ï¿½.ï¿½iE=ï¿½O'>ï¿½.ï¿½{ï¿½ï¿½J|ï¿½oï¿½ï¿½Dï¿½hyï¿½Aï¿½vï¿½ï¿½Hï¿½J|ï¿½ï¿½ï¿½^ï¿½hï¿½ bA4ï¿½ï¿½.aUï¿½ï¿½ï¿½>ï¿½ï¿½mï¿½E,ï¿½ï¿½Rc]ï¿½-Òªï¿½ï¿½mï¿½ï¿½Dï¿½h%Kï¿½Aï¿½vï¿½ï¿½Hï¿½J|ï¿½ï¿½ï¿½^ï¿½hï¿½,bY4ï¿½ï¿½.ï¿½iUï¿½ï¿½ï¿½>ï¿½ï¿½mï¿½UDï¿½ï¿½5ï¿½%ï¿½"ï¿½*ï¿½ï¿½'z]ï¿½mï¿½ï¿½ï¿½UÑ Fï¿½D[ï¿½U%>ï¿½ï¿½Dï¿½Kï¿½ï¿½Vï¿½&ï¿½hï¿½hï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½D\jï¿½Kï¿½EZUï¿½#ï¿½Oï¿½ï¿½Dï¿½huï¿½Aï¿½vï¿½ï¿½Hï¿½J|ï¿½ï¿½ï¿½^ï¿½hmQï¿½EÑ Fï¿½D[ï¿½U%>ï¿½ï¿½Dï¿½Kï¿½ï¿½ï¿½$ï¿½hPï¿½]ï¿½-ÒªzÂŸN|ï¿½]ï¿½3qkJ|ï¿½ï„»Dï¿½hyï¿½Aï¿½vï¿½ï¿½HkJ|ï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½ bA4ï¿½ï¿½.aMï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½E,ï¿½ï¿½Rc]ï¿½#Òšï¿½ï¿½mï¿½ï¿½Dï¿½h%Kï¿½Aï¿½vï¿½ï¿½HkJ|ï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½,bY4ï¿½ï¿½.ï¿½iMï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½UDï¿½ï¿½5ï¿½%:"ï¿½)ï¿½ï¿½'z]ï¿½cï¿½ï¿½ï¿½UÑ Fï¿½DGï¿½5%>ï¿½ï¿½Dï¿½Ktï¿½Vï¿½&ï¿½hï¿½èˆ´ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½D\jï¿½KtDZSï¿½#ï¿½Oï¿½ï¿½Dï¿½huï¿½Aï¿½vï¿½ï¿½HkJ|ï¿½ï¿½ï¿½^ï¿½ï¿½mQï¿½EÑ Fï¿½DGï¿½5%>ï¿½ï¿½Dï¿½Ktï¿½ï¿½$ï¿½hPï¿½]ï¿½#ÒšzÂŸN|ï¿½]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½~ï¿½Kï¿½1/ï¿½hï¿½è‹´ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½
"Dï¿½ï¿½Ö•ï¿½ï¿½ï¿½.ï¿½7ZQÄ¢h)5ï¿½%ï¿½"ï¿½+ï¿½ï¿½ï¿½Fï¿½Kï¿½Vï¿½$ï¿½hï¿½è‹´ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½ï¿½"ï¿½Eï¿½ï¿½}ï¿½Ö•ï¿½ï¿½ï¿½.ï¿½7ZEÄŠhPï¿½]ï¿½/Òºï¿½}ï¿½ï¿½%ï¿½Fï¿½ï¿½Xjï¿½Kï¿½EZWï¿½#ï¿½Oï¿½ï¿½Dï¿½h5kï¿½Aï¿½vï¿½ï¿½Hï¿½J|ï¿½ï¿½ï¿½^ï¿½ï¿½mAï¿½Ñ Fï¿½D_ï¿½u%>ï¿½ï¿½Dï¿½Kï¿½Vï¿½.ï¿½hï¿½è‹´ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½E\jï¿½Kï¿½EZWï¿½#ï¿½Oï¿½ï¿½Dï¿½hK".ï¿½5ï¿½%ï¿½"ï¿½ï¿½G ï¿½ï¿½ï¿½ï¿½%ï¿½J|ï¿½ï¿½ï¿½ï¿½ï¿½hyï¿½Aï¿½vï¿½ï¿½HJ|ï¿½ï¿½ï¿½^ï¿½ï¿½ bA4ï¿½ï¿½.aCï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½E,ï¿½ï¿½Rc]b Ò†ï¿½ï¿½mï¿½ï¿½ï¿½ï¿½h%Kï¿½Aï¿½vï¿½ï¿½HJ|ï¿½ï¿½ï¿½^ï¿½ï¿½,bY4ï¿½ï¿½.1iCï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½UDï¿½ï¿½5ï¿½%"m(ï¿½ï¿½'z]b`ï¿½ï¿½ï¿½UÑ Fï¿½ï¿½@ï¿½%>ï¿½ï¿½Dï¿½Kï¿½Vï¿½&ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½D\jï¿½KDï¿½Pï¿½#ï¿½Oï¿½ï¿½ï¿½ï¿½huï¿½Aï¿½vï¿½ï¿½HJ|ï¿½ï¿½ï¿½^ï¿½mQï¿½EÑ Fï¿½ï¿½@ï¿½%>ï¿½ï¿½Dï¿½Kï¿½ï¿½$ï¿½hPï¿½]b Ò†zÂŸN|ï¿½]bSï¿½aKï¿½ï¿½ï¿½ï¿½.ï¿½iï¿½ï¿½ï¿½yÑ Fï¿½Ä¦H[J|ï¿½ï¿½ï¿½^ï¿½ï¿½4ZAÄ‚hPï¿½]Â–ï¿½}ï¿½ï¿½%6ï¿½Vï¿½(ZJï¿½uï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½%6ï¿½Vï¿½$ï¿½hï¿½ï¿½iKï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½F+ï¿½Xjï¿½Klï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½Mï¿½UDï¿½ï¿½5ï¿½%6Eï¿½Rï¿½#ï¿½Oï¿½ï¿½Ä¦Ñª"VEï¿½ï¿½ï¿½"m)ï¿½ï¿½'z]bï¿½h5kï¿½Aï¿½vï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½iï¿½Dï¿½ï¿½ï¿½"m)ï¿½ï¿½'z]bï¿½huï¿½Aï¿½vï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½iï¿½EEï¿½ï¿½ï¿½"m)ï¿½ï¿½'z]bï¿½hK".ï¿½5ï¿½%6Eï¿½Rï¿½@ï¿½Ó‰ï¿½Kï¿½vï¿½ï¿½?wï¿½ï¿½ï¿½ï¿½"ï¿½Eï¿½ï¿½Cï¿½vï¿½ï¿½ï¿½ï¿½.14ZAÄ‚hPï¿½]Â®ï¿½}ï¿½ï¿½%ï¿½F+ï¿½X-ï¿½Æºï¿½Pï¿½]%>ï¿½ï¿½ï¿½ï¿½uï¿½ï¿½ï¿½J"ï¿½Dï¿½ï¿½Cï¿½vï¿½ï¿½ï¿½ï¿½.14ZYÄ²hPï¿½]b(Ò®ï¿½}ï¿½ï¿½%ï¿½Fï¿½ï¿½Xjï¿½KEï¿½Uï¿½#ï¿½Oï¿½ï¿½ï¿½ï¿½hUï¿½ï¿½Aï¿½vï¿½ï¿½Hï¿½J|ï¿½ï¿½ï¿½^ï¿½ï¿½&bM4ï¿½ï¿½.1iWï¿½ï¿½ï¿½>ï¿½ï¿½Cï¿½-ï¿½ï¿½ ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½ï¿½"ï¿½Eï¿½ï¿½Cï¿½vï¿½ï¿½ï¿½ï¿½.14Ú¢ï¿½ï¿½ï¿½Aï¿½vï¿½ï¿½Hï¿½J|ï¿½ï¿½ï¿½^ï¿½mIï¿½%Ñ Fï¿½ï¿½Pï¿½]ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½Hï¿½aOï¿½ï¿½ï¿½pï¿½-/b^4ï¿½ï¿½.1iOï¿½ï¿½ï¿½>ï¿½ï¿½#ï¿½D,ï¿½5ï¿½% ï¿½)ï¿½ï¿½'z]bdï¿½ï¿½ï¿½Eï¿½Rjï¿½Kï¿½Dï¿½Sï¿½#ï¿½ï¿½ï¿½^ï¿½ï¿½$bI4ï¿½ï¿½.1iOï¿½ï¿½ï¿½>ï¿½ï¿½#ï¿½ï¿½E,ï¿½5ï¿½%F"ï¿½)ï¿½ï¿½'z]bdï¿½ï¿½ï¿½Ñ Fï¿½ï¿½Hï¿½=%>ï¿½ï¿½Dï¿½Kï¿½ï¿½Vï¿½*ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½ï¿½j"ï¿½Dï¿½ï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.12Ú‚ï¿½ï¿½Aï¿½vï¿½ï¿½H{J|ï¿½ï¿½ï¿½^ï¿½ï¿½.b]4ï¿½ï¿½.1iOï¿½ï¿½ï¿½>ï¿½ï¿½#ï¿½-ï¿½ï¿½(ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½Gxï¿½ï¿½uï¿½ï¿½Ñ–D\jï¿½Kï¿½Dï¿½Sï¿½@ï¿½Ó‰^ï¿½Hï¿½hï¿½ï¿½ï¿½JT~ï¿½ï¿½bï¿½ï¿½ï¿½^ï¿½ï¿½İ·î¤“Oï¿½7ï¿½ï¿½+ï¿½ï¿½ï¿½ï¿½ï¿½ksï¿½|ï¿½\ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½jï¿½XyQï¿½ï¿½`ï¿½*ï¿½)ï¿½Oyl2ï¿½ï¿½ï¿½ï¿½'Snï¿½ï¿½|f2ï¿½;ï¿½ï¿½ï¿½dï¿½?ï¿½ï¿½|v2ï¿½ï¿½ï¿½S>7ï¿½ï¿½ï¿½ï¿½)ONï¿½ï¿½r<ï¿½ï¿½ï¿½Evï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ßŸï¿½ï¿½ï¿½ï¿½w(ï¿½ëªï¿½(ï¿½#i.ï¿½ï¿½ã¤ï¿½ï¿½?Èï¿½ï¿½ï¿½	ï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½2ï¿½qmï¿½ï¿½5ï¿½ï¿½0ï¿½}9~ï¿½ï¿½ï¿½ï¿½6ï¿½#ï¿½g?ï¿½ï¿½ï¿½\'sï¿½ï¿½EDï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½8}×­ï¿½ï¿½yQï¿½DCï¿½ï¿½^ï¿½ï¿½ï¿½Ó­ï¿½$ï¿½(Wï¿½ï¿½Oï¿½ï¿½:ï¿½ï¿½/~ï¿½{]ï¿½ï¿½uï¿½gï¿½G|ï¿½ï¿½fÏˆRï¿½Ï¸ï¿½_Ôï¿½ï¿½sï¿½ï¿½ï¿½EQï¿½ï¿½ï¿½mï¿½Bï¿½ï¿½qï¿½Y'ÏŠRï¿½;ï¿½rï¿½\ï¿½ï¿½WVgncIï¿½y>;O?WWoï¿½$Î‹Rï¿½ïµ›nkï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½f&ï¿½,ï¿½9ï¿½ï¿½pdN#N7ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½;ï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½ÆŠ(ï¿½ECï¿½ï¿½Kï¿½ï¿½7oï¿½$ï¿½ï¿½*ÂŸwï¿½ï¿½ï¿½ï¿½ï¿½Äª(DCï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½Iï¿½xAï¿½ï¿½hï¿½%Nï¿½ï¿½ï¿½ï¿½5Q.ï¿½ï¿½ï¿½5ï¿½xï¿½ï¿½İ™{}Qï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½[ï¿½IÛ¸ ï¿½%ï¿½~ï¿½%Ş½ï¿½Ã™ï¿½xIrï¿½/ï¿½Jï¿½ï¿½Aï¿½qï¿½}ï¿½ï¿½Wï¿½,_f'wGï¿½*Sz&|4ï¿½ï¿½uï¿½)=>ï¿½XĞºÊ”ï¿½	M,h]==>ï¿½XĞºÊ”ï¿½	M,h]eJÏ„ï¿½&ï¿½ï¿½2ï¿½gï¿½GZWï¿½ï¿½3á£‰ï¿½ï¿½Lï¿½ï¿½ï¿½Ä‚FWï¿½ï¿½ï¿½Ä‚ï¿½Uï¿½ï¿½Lï¿½hbAï¿½*Sz&|4ï¿½ï¿½uï¿½)=>ï¿½XĞºÊ”ï¿½	M,h]eJÏ„ï¿½&ï¿½ï¿½2ï¿½gï¿½GZWï¿½ï¿½3á£‰ï¿½ï¿½Lï¿½ï¿½ï¿½Ä‚ï¿½Uï¿½ï¿½Lï¿½hbAï¿½*ï¿½z&ï¿½G'ï¿½ï¿½ï¿½Pï¿½Ê”>ï¿½XĞ¶ï¿½);&|4ï¿½ï¿½m+SvLï¿½hbAï¿½Vï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½Lï¿½1á£‰m[ï¿½ï¿½cï¿½GÚ¶2eÇ„ï¿½&ï¿½meÊ	M,hï¿½Ê”>ï¿½XĞ¶ï¿½);&|4ï¿½ï¿½m+SvLï¿½hbAï¿½Vï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½Lï¿½1á£‰m[ï¿½ï¿½cï¿½GÚ¶2eÇ„ï¿½&ï¿½meÊ	M,hï¿½Ê”>ï¿½XĞ¶ï¿½);&|4ï¿½ï¿½m+SvLï¿½hbAï¿½VZï¿½ï¿½ï¿½ï¿½ï¿½WBï¿½+SLï¿½hbAï¿½Wï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½L90á£‰m_ï¿½r`ï¿½GÚ¾2ï¿½ï¿½ï¿½ï¿½&ï¿½}eÊ	M,hï¿½Ê”>ï¿½Xï¿½ï¿½ï¿½)&|4ï¿½ï¿½ï¿½+SLï¿½hbAï¿½Wï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½L90á£‰m_ï¿½r`ï¿½GÚ¾2ï¿½ï¿½ï¿½ï¿½&ï¿½}eÊ	M,hï¿½Ê”>ï¿½Xï¿½ï¿½ï¿½)&|4ï¿½ï¿½ï¿½+SLï¿½hbAï¿½Wï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½L90á£‰m_iu`ï¿½tï¿½ï¿½ï¿½ï¿½1lï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½"6Mï¿½hbAkï¿½3"ï¿½&|4ï¿½ï¿½5tï¿½iï¿½GZ#ï¿½Oï¿½1á£‰ï¿½ï¿½ï¿½4jï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ShLï¿½hbAkï¿½hÓ„ï¿½&ï¿½ï¿½>ï¿½ï¿½iï¿½GZCç¨š&|4ï¿½ï¿½5rï¿½>ï¿½Xï¿½9}
ï¿½	M,h}ï¿½iÓ„ï¿½&ï¿½FNï¿½Bcï¿½GZ#ï¿½Oï¿½1á£‰ï¿½ï¿½Ó§Ğ˜ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ShLï¿½hbAkï¿½ï¿½)4&|4ï¿½ï¿½5rï¿½>ï¿½Xï¿½ï¿½~ï¿½iï¿½ï¿½ï¿½c)ï¿½ï¿½Ê”ï¿½	>ï¿½%RWï¿½ï¿½3ï¿½ï¿½ï¿½Dï¿½*Sz&|ï¿½<ï¿½H]eJÏ„ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½X"uï¿½)=>|Kï¿½ï¿½2ï¿½gÂ‡ï¿½cï¿½ï¿½Uï¿½ï¿½Lï¿½ï¿½y,ï¿½ï¿½Ê”ï¿½	>ï¿½%RWï¿½ï¿½3ï¿½ï¿½ï¿½Dï¿½*Sz&|ï¿½<ï¿½H]eJÏ„ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½X"uï¿½)=>|Kï¿½ï¿½2ï¿½gÂ‡ï¿½cï¿½ï¿½Uï¿½ï¿½Lï¿½ï¿½y,ï¿½ï¿½Ê”ï¿½	>ï¿½%RWï¿½ï¿½3ï¿½ï¿½ï¿½Dï¿½*Sz&|ï¿½<ï¿½H]ï¿½UÏ„ï¿½&Vvï¿½ï¿½ï¿½Â³+,g_kï¿½Oï¿½ï¿½;sIï¿½ï¿½Iï¿½ï¿½ï¿½'ï¿½bSï¿½ï¿½{.Ù”ï¿½ï¿½)ï¿½OMï¿½Sï¿½$Éµï¿½ï¿½ï¿½Ù”&ï¿½ï¿½$rï¿½ï¿½ï¿½ï¿½Fcï¿½Ú“ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½Ïï¿½H\+ï¿½ï¿½ï¿½ï¿½ï¿½1-%ï¿½N#ï¿½tU
ÓŠï¿½ï¿½ï¿½Jï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½haï¿½
ï¿½ï¿½yvï¿½3|ï¿½#vï¿½E;ï¿½|ï¿½ï¿½Ö» ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½rï¿½ï¿½ï¿½ï¿½wï¿½^ï¿½ï¿½ï¿½vï¿½3ï¿½ï¿½Iï¿½s%?ï¿½ï¿½{|ï¿½ï¿½ï¿½gï¿½ï¿½ï¿½/?y|8*+ï¿½\-?yï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½YKw#}ï¿½ï¿½Æ‚^Ñ¦ï¿½|ï¿½ï¿½Wbï¿½ï¿½FQoï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}>#]ï¿½;aï¿½/ï¿½ï¿½ï¿½'ï¿½5ï¿½ï¿½ï¿½ï¿½dï¿½!ï¿½8ï¿½Mï¿½ï¿½q|ï¿½ï¿½Í®j:yï¿½Gï¿½kï¿½ï¿½?ï¿½ï¿½ï¿½eJï¿½}4ï¿½ï¿½ë««Eï¿½ï¿½ï¿½ï¿½#(ï¿½Fï¿½ï¿½ï¿½ï¿½cï¿½ï¿½Oï¿½ï¿½18ï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mKï¿½ï¿½ï¿½ï¿½lKÇ„ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<[ï¿½ï¿½wtmï¿½ï¿½ï¿½ï¿½ï¿½UŞ¿ï¿½)ï¿½ï¿½xï¿½wï¿½ï¿½ï¿½"ï¿½ï¿½sï¿½)Iï¿½ï¿½ï¿½sï¿½ï¿½ï¿½kï¿½ï¿½{ï¿½Ç·3İ›ï¿½ï¿½^[ï¿½n/ï¿½t{ï¿½u>ï¿½rï¿½=ï¿½\Aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½_yï¿½ï¿½7ï¿½Æ²~*Kï¿½{vï¿½ï¿½)ï¿½tLï¿½ï¿½u556ï¿½1Yï¿½ï¿½ï¿½8ï¿½ï¿½×ƒï¿½^~ï¿½ï¿½kï¿½zï¿½zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½gï¿½_cï¿½lï¿½sï¿½mï¿½ï¿½\ï¿½5:ï¿½sË«ï¿½~ï¿½ï¿½Gï¿½~ï¿½3ï¿½}ï¿½ï¿½;ï¿½7]ï¿½ï¿½Mï¿½ï¿½ï¿½GvE#ï¿½ï¿½ï¿½ï¿½>4^ï¿½ï¿½ï¿½ï¿½ï¿½å¯¾tï¿½Ê‹/Ü¸ï¿½ï¿½ï¿½k|ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½F|ï¿½ï¿½ï¿½ï¿½Scï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½Ò¾ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½_mï¿½ÙŠï¿½Ãˆï¿½,ï¿½é•ƒï¿½<ï¿½>ï¿½ï¿½ï¿½Gï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½KFdÄ³qï¿½ï¿½kXï¿½ï¿½>uï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½{ï¿½ï¿½7oï¿½ï¿½vWë¤›ï¿½wgï¿½ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½}z<ï¿½oï¿½}ï¿½ï¿½ï¿½wï¿½ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½Ñ­ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½kï¿½gï¿½uï¿½ï¿½ï¿½ï¿½O-Eï¿½^ï¿½5>ï¿½>ï¿½vï¿½iTï¿½rß¨ï¿½ï¿½ï¿½ï¿½Şºsï¿½ï¿½ï¿½ï¿½xï¿½wï¿½ï¿½}ï¿½Î†qï¿½1ï¿½ï¿½eï¿½7ï¿½ï¿½cï¿½ï¿½ï¿½ï¿½oGï¿½w?ï¿½ï¿½Ç•çŸ½ï¿½>:
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÍŸï¿½ï¿½ï¿½s~ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½vï¿½ï¿½ï¿½O\ï¿½ï¿½ï¯¤ÓŸï¿½ï¿½rï¿½z_ï¿½ï¿½%ï¿½$?'}&ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½Õˆï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½kNGXï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Jzï¿½ï¿½ï¿½ï¿½ayï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½[yaï¿½é˜–ï¿½ï¿½ï½¯$7Nï¿½l:ï¿½_ï¿½.{ï¿½PCï¿½ï¿½ï¿½ï¿½{ï¿½qï¿½-Gï¿½7Wï¿½ï¿½ï¿½ï¿½ï¿½È¶ï¿½6ï¿½rï¿½Mï¿½ï¿½[~ï¿½ï¿½ï¿½o=dï¿½\ï¿½×“ßœï¿½7ï¿½ä¿´7Mï¿½ï¿½ï¿½Ôµï¿½+ï¿½$ï¿½ï¿½Ë6ï¿½ï¿½ï¿½Dï¿½ï¿½eï¿½8]6ï¿½ï¿½ï¿½Gï¿½ï¿½eï¿½3ï¿½lYï¿½ï¿½Jï¿½ï¿½/Fï¿½eï¿½ï¿½gï¿½ï¿½ï¿½ï¿½Hï¿½]vï¿½ï¿½9ï¿½##=
ï¿½qï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½|ï¿½oï¿½dï¿½}ï¿½ï¿½ÓŸi\ï¿½<Û·ï¿½'cï¿½ï¿½dï¿½ï¿½ï¿½tï¿½ï¿½cï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½eï¿½fï¿½sï¿½zokï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~iï¿½,gï¿½N~.iï¿½Pï¿½ï¿½ï¿½cï¿½ï¿½ï¿½8ï¿½ï¿½Î²ï¿½ï¿½ï¿½ï¿½ï¿½ä¸¿sê²¹ï¿½ï¿½:î³Ÿï¿½ï¿½c([v9ï¿½ï¿½ï¿½ï¿½1ï¿½-ï¿½2y~Wf.ï¿½ï¿½1ï¿½Ñ±Zï¿½,ï¿½ï¿½,ËœGï¿½]ï¿½,ï¿½ï¿½,ËœGï¿½]ï¿½,ï¿½ï¿½,ËœGï¿½İ˜,ï¿½ï¿½,ËœGï¿½İš,ï¿½ï¿½,ËœGï¿½İ,ï¿½ï¿½,ËœGï¿½İ›,ï¿½ï¿½,Ëœï¿½ï¿½{ï¿½ï¿½s?{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½:ï¿½ï¿½Fï¿½Uï¿½ï¿½Î‰,[.)gï¿½ï¿½kï¿½:ï¿½ï¿½ï¿½ï¿½ï¿½L2ï¿½ï¿½×‡wï¿½}ï¿½,Ó²ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ô²Ïï¿½ï¿½ï¿½ï¿½]ï¿½4&ï¿½ï¿½&ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½ï¿½o%ï¿½ï¿½  ï¿½ï¿½ PK     ! ï¿½*ï¿½ï¿½T  u   docProps/core.xml ï¿½(ï¿½                                                                                                                                                                                                                                                                 ï¿½ï¿½]Kï¿½0ï¿½ï¿½ï¿½Cï¿½}ï¿½ï¿½ï¿½CBÛÊ®6ï¿½(Ş…ï¿½ï¿½Vl>H2ï¿½ï¿½{ï¿½vï¿½zï¿½UHŞ“'ï¿½ï¿½/Oï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½$E(ï¿½Eï¿½ï¿½zİ®ï¿½{9Ï”`ï¿½VPï¿½Zï¿½ï¿½797ï¿½kï¿½Vï¿½ï¿½ï¿½rï¿½ï¿½ï¿½7cï¿½ ï¿½Kï¿½Bï¿½ï¿½N[ï¿½|ï¿½ï¿½=6ï¿½ï¿½=ï¿½,MXï¿½gï¿½yï¿½;`lF":#ï¿½ï¿½hï¿½ 8ï¿½$(ï¿½0Iï¿½ï¿½zï¿½ï¿½ï¿½yï¿½ï¿½Lï¿½ï¿½ï¿½	ï¿½ï¿½vï¿½lï¿½ï¿½ï¿½>ï¿½j6Mï¿½4ï¿½ï¿½Fï¿½Oï¿½ï¿½fï¿½ï¿½Gï¿½+ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½[`^Û²ï¿½oï¿½Sï¿½ï¿½ï¿½aW`Íœß„ï¿½wï¿½ï¿½ï¿½\+ï¿½ï¿½ï¿½Pï¿½ï¿½6ï¿½ï¿½-ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½Gï¿½tï¿½tï¿½ï¿½ï¿½ï¿½ï¿½+Tfi6ï¿½Igï¿½-YP2ï¿½wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½p Ï¦ï¿½Mï¿½gï¿½ï¿½	ï¿½({ï¿½ï¿½ï¿½ï¿½  ï¿½ï¿½ PK     ! ï¿½)ÆŒ     docProps/app.xml ï¿½(ï¿½                                                                                                                                                                                                                                                                 ï¿½ï¿½Anï¿½0Eï¿½zï¿½ï¿½ï¿½rï¿½A1ï¿½^ï¿½ï¿½;ï¿½Oï¿½ï¿½Å–&ï¿½Xï¿½{ï¿½ï¿½ï¿½%!ï¿½ï¿½vï¿½ï¿½pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½D.ï¿½Rï¿½gï¿½lï¿½\Ø–ï¿½iï¿½ï¿½ï¿½ï¿½*ï¿½1`)ï¿½Hï¿½ï¿½|ï¿½Ğ«[Lï¿½Dï¿½TÊ†ï¿½](Eï¿½ï¿½ï¿½,ï¿½!+uL;ï¿½L[ï¿½ï¿½Y|ï¿½vï¿½ï¿½ï¿½ï¿½(nCï¿½ï¿½e{2ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½|ï¿½ï¿½9ï¿½ï¿½è»¶ï¿½ï¿½ï¿½[ï¿½ï¿½Î¦Hï¿½fï¿½ï¿½`ï¿½k5uï¿½[ï¿½ï¿½'ï¿½GSh5]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½zkï¿½%Bï¿½
\"ï¿½;^th9&Aï¿½Wï¿½ï¿½Jï¿½ï¿½@ï¿½ã”²ï¿½ï¿½ pï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½ï¿½8ï¿½eï¿½$*ï¿½ï¿½ooï¿½>jï¿½ï¿½Fm(ï¿½[ï¿½ï¿½ï¿½6ï¿½a çƒ½ï¿½È“ï¿½sÒcï¿½ï¿½ï¿½^Aï¿½ï¿½ï¿½Ï§ï¿½Ãˆ=ï¿½DÏœï¿½7ï¿½'ï¿½ï¿½ï¿½ï¿½ï¿½Ozj7ï¿½_#<oï¿½u	ï¿½ï¿½ï¿½)ï¿½SC/szï¿½ï¿½&ï¿½ï¿½-Vï¿½3ï¿½
ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ofï¿½ï¿½"ï¿½å¤§ï¿½ï¿½ï¿½5/   ï¿½ï¿½ PK-      ! eß’ï¿½l  ï¿½                   [Content_Types].xmlPK-      ! ï¿½ï¿½%S  ï¿½               ï¿½  _rels/.relsPK-      ! V%ï¿½ï¿½#                 ï¿½  xl/workbook.xmlPK-      ! ï¿½>ï¿½ï¿½ï¿½   ï¿½               ,
  xl/_rels/workbook.xml.relsPK-      ! O)ï¿½ï¿½  _               _  xl/worksheets/sheet1.xmlPK-      ! ï¿½%ï¿½f  S               ï¿½  xl/theme/theme1.xmlPK-      ! !ï¿½Ã°5  ï¿½               *  xl/styles.xmlPK-      ! hiï¿½  ï¿½               ï¿½  xl/sharedStrings.xmlPK-      ! ï¿½ï¿½ï¿½  jï¿½               ï¿½  docProps/thumbnail.wmfPK-      ! ï¿½*ï¿½ï¿½T  u               ï¿½2  docProps/core.xmlPK-      ! ï¿½)ÆŒ                 5  docProps/app.xmlPK      ï¿½  ï¿½7    
```

## tests\conftest.py
```
"""
Test configuration module.
"""
import os
import sys
from pathlib import Path

# Add src directory to Python path
src_path = str(Path(__file__).parent.parent)
sys.path.insert(0, src_path)

```

## src\gui\__init__.py
```
"""
GUI package initialization.
"""
from .main_window import MainWindow

__all__ = ['MainWindow']

```

## src\gui\main_window.py
```
"""
Main window module for the PDF converter application.
"""
import os
import customtkinter as ctk
from PIL import Image
from tkinter import filedialog, messagebox
import threading
import pandas as pd
from datetime import datetime

from ..core.image_processor import ImageProcessor
from ..core.text_normalizer import TextNormalizer

class MainWindow(ctk.CTk):
    """Main application window."""
    
    def __init__(self):
        super().__init__()
        
        # Initialize components
        self.image_processor = ImageProcessor()
        self.text_normalizer = TextNormalizer()
        self.procesando = False
        self.modo_comprimido = ctk.BooleanVar(value=False)
        self.directorio_salida = None
        
        self._setup_window()
        self._create_widgets()
        
    def _setup_window(self):
        """Configure main window properties."""
        self.title("Herramientas de Productividad")
        self.geometry("500x500")
        self.resizable(False, False)
        
        # Configure theme
        ctk.set_appearance_mode("system")
        ctk.set_default_color_theme("blue")
        
    def _create_widgets(self):
        """Create and configure GUI widgets."""
        # Create tab view
        self.notebook = ctk.CTkTabview(self)
        self.notebook.pack(pady=20, padx=20, fill="both", expand=True)
        
        # Add tabs in desired order
        self.tab_folders = self.notebook.add("Crear Carpetas")
        self.tab_convert = self.notebook.add("imagenes a PDFs")
        
        # Create tab contents
        self._create_folders_tab()
        self._create_convert_tab()
        
    def _create_folders_tab(self):
        """Create content for folders tab."""
        # Main frame with minimal padding
        frame = ctk.CTkFrame(self.tab_folders)
        frame.pack(pady=10, padx=10, fill="both", expand=True)
        
        # Title
        titulo = ctk.CTkLabel(frame, text="CreaciÃ³n Masiva de Carpetas", 
                            font=ctk.CTkFont(size=20, weight="bold"))
        titulo.pack(pady=5)

        # Description
        descripcion1 = ctk.CTkLabel(frame, 
            text="Descarga la plantilla Excel, completa los datos con ID, NOMBRES y APELLIDOS.",
            font=ctk.CTkFont(size=12),
            text_color="#CCCCCC"
        )
        descripcion1.pack(pady=2)

        descripcion2 = ctk.CTkLabel(frame, 
            text="Luego, carga el archivo para crear automÃ¡ticamente las carpetas.",
            font=ctk.CTkFont(size=12),
            text_color="#CCCCCC"
        )
        descripcion2.pack(pady=(0,5))
        
        # First row frame (template and load)
        row1_frame = ctk.CTkFrame(frame)
        row1_frame.pack(fill="x", padx=10, pady=10)
        
        # Left column: Download template
        btn_download = ctk.CTkButton(
            row1_frame,
            text="ğŸ“¥ Descargar Plantilla",
            command=self._download_template
        )
        btn_download.pack(side="left", padx=5)
        
        # Right column: Load template
        btn_load = ctk.CTkButton(
            row1_frame,
            text="ğŸ“¤ Cargar Plantilla",
            command=self._load_template
        )
        btn_load.pack(side="right", padx=5)
        
        # Status label
        self.folders_status_label = ctk.CTkLabel(frame, 
            text="Estado: Esperando plantilla...",
            font=ctk.CTkFont(size=12)
        )
        self.folders_status_label.pack(pady=10)
        
        # Details area
        self.folders_details_text = ctk.CTkTextbox(frame, height=100)
        self.folders_details_text.pack(fill="x", padx=10, pady=(5,10))
        self.folders_details_text.configure(state="disabled")

        # Add footer
        self._create_footer(frame)
        
    def _create_convert_tab(self):
        """Create content for convert tab."""
        # Main frame with minimal padding
        frame = ctk.CTkFrame(self.tab_convert)
        frame.pack(pady=10, padx=10, fill="both", expand=True)

        # Title
        titulo = ctk.CTkLabel(frame, text="Conversor de ImÃ¡genes a PDF", 
                            font=ctk.CTkFont(size=20, weight="bold"))
        titulo.pack(pady=5)

        # Compress checkbox
        self.cb_compress = ctk.CTkCheckBox(
            frame,
            text="Generar archivos PDFs en un nuevo archivo ZIP",
            variable=self.modo_comprimido,
            onvalue=True,
            offvalue=False
        )
        self.cb_compress.pack(pady=10)

        # Select folder button
        self.btn_select = ctk.CTkButton(
            frame,
            text="ğŸ“ Seleccionar Carpeta de ImÃ¡genes",
            command=self._select_folder
        )
        self.btn_select.pack(pady=10)

        # Progress bar
        self.progress_bar = ctk.CTkProgressBar(frame)
        self.progress_bar.pack(fill="x", padx=10, pady=5)
        self.progress_bar.set(0)

        # Progress label
        self.progress_label = ctk.CTkLabel(frame, text="0%")
        self.progress_label.pack(pady=5)

        # Status label
        self.status_label = ctk.CTkLabel(
            frame,
            text="Estado: Esperando selecciÃ³n de carpeta...",
            font=ctk.CTkFont(size=12)
        )
        self.status_label.pack(pady=5)

        # Details area
        self.details_text = ctk.CTkTextbox(frame, height=75)
        self.details_text.pack(fill="x", padx=10, pady=(5,10))
        self.details_text.configure(state="disabled")

        # Add footer
        self._create_footer(frame)
        
    def _create_footer(self, parent_frame):
        """Create footer with credits."""
        # Internal frame for credits
        credits_internal = ctk.CTkFrame(parent_frame, fg_color="transparent")
        credits_internal.pack(side="bottom", fill="x", pady=(10, 3))

        # First line: Developer and year
        credits_line1 = ctk.CTkLabel(
            credits_internal,
            text="Desarrollado por: Luis Fernando Moreno Montoya | 2024",
            font=ctk.CTkFont(size=13),
            text_color="#CCCCCC"
        )
        credits_line1.pack(pady=(10, 3))
        
        # Second line: Special message (split for heart color)
        message_frame = ctk.CTkFrame(credits_internal, fg_color="transparent")
        message_frame.pack(pady=(3, 10))

        # First part of message
        part1 = ctk.CTkLabel(
            message_frame,
            text="Hecho con ",
            font=ctk.CTkFont(size=13),
            text_color="#CCCCCC"
        )
        part1.pack(side="left")

        # Red heart
        heart = ctk.CTkLabel(
            message_frame,
            text="â™¥",
            font=ctk.CTkFont(size=13),
            text_color="#FF0000"
        )
        heart.pack(side="left")
        
    def _download_template(self):
        """Handle template download."""
        try:
            # Create new workbook
            wb = pd.DataFrame(columns=['ID', 'NOMBRES', 'APELLIDOS'])
            
            # Save dialog
            filename = filedialog.asksaveasfilename(
                title="Guardar plantilla como",
                defaultextension=".xlsx",
                initialfile="Plantilla Nombres Carpetas.xlsx",
                filetypes=[("Excel files", "*.xlsx")]
            )
            
            if filename:
                # Save template
                wb.to_excel(filename, index=False)
                messagebox.showinfo(
                    "Ã‰xito",
                    "Plantilla descargada exitosamente"
                )
                
        except Exception as e:
            messagebox.showerror(
                "Error",
                f"Error al descargar plantilla: {str(e)}"
            )
            
    def _load_template(self):
        """Handle template loading and folder creation."""
        try:
            # Select Excel file
            excel_path = filedialog.askopenfilename(
                title="Seleccionar plantilla Excel",
                filetypes=[("Excel files", "*.xlsx")]
            )
            
            if not excel_path:
                return
                
            # Select output directory
            output_dir = filedialog.askdirectory(
                title="Seleccionar directorio de salida"
            )
            
            if not output_dir:
                return
                
            # Update status
            self.folders_status_label.configure(text="Estado: Procesando...")
            self._add_folder_detail(f"Cargando plantilla: {excel_path}")
            
            # Read Excel file
            df = pd.read_excel(excel_path)
            
            # Validate required columns
            if 'ID' not in df.columns or 'NOMBRES' not in df.columns:
                messagebox.showerror(
                    "Error",
                    "La plantilla debe tener las columnas 'ID' y 'NOMBRES'"
                )
                self.folders_status_label.configure(text="Estado: Error")
                return
                
            # Create folders
            folders_created = 0
            self.folders_details_text.configure(state="normal")
            self.folders_details_text.delete("1.0", "end")
            
            for _, row in df.iterrows():
                # Normalize folder name
                folder_name = self.text_normalizer.normalize_text(
                    f"{row['ID']} - {row['NOMBRES']}"
                )
                
                if 'APELLIDOS' in df.columns and not pd.isna(row['APELLIDOS']):
                    folder_name += f" {row['APELLIDOS']}"
                    
                # Ensure the folder name is in uppercase
                folder_name = folder_name.upper()
                
                folder_path = os.path.join(output_dir, folder_name)
                
                # Create folder
                os.makedirs(folder_path, exist_ok=True)
                folders_created += 1
                
                # Update progress
                self._add_folder_detail(f"âœ“ Creada carpeta: {folder_name}")
                
            # Show success message
            self.folders_status_label.configure(text=f"Estado: {folders_created} carpetas creadas")
            messagebox.showinfo(
                "Ã‰xito",
                f"Se han creado {folders_created} carpetas exitosamente"
            )
            
        except Exception as e:
            self.folders_status_label.configure(text="Estado: Error")
            messagebox.showerror(
                "Error",
                f"Error durante la creaciÃ³n de carpetas: {str(e)}"
            )
            
    def _select_folder(self):
        """Handle folder selection for image conversion."""
        if self.procesando:
            self.procesando = False
            self.btn_select.configure(text="ğŸ“ Seleccionar Carpeta de ImÃ¡genes")
            return
            
        directory = filedialog.askdirectory(
            title="Seleccionar carpeta con imÃ¡genes"
        )
        
        if directory:
            self._process_folder(directory)
            
    def _process_folder(self, directory: str):
        """Process all images in the directory."""
        try:
            self.procesando = True
            self.btn_select.configure(text="ğŸ›‘ Cancelar Proceso")
            self._add_detail(f"Procesando carpeta: {directory}")
            
            # Get output file name
            if self.modo_comprimido.get():
                output_file = filedialog.asksaveasfilename(
                    title="Guardar ZIP como",
                    defaultextension=".zip",
                    filetypes=[("ZIP files", "*.zip")],
                    initialfile=os.path.basename(directory) + ".zip"
                )
            else:
                output_file = filedialog.asksaveasfilename(
                    title="Guardar PDF como",
                    defaultextension=".pdf",
                    filetypes=[("PDF files", "*.pdf")],
                    initialfile=os.path.basename(directory) + ".pdf"
                )
                
            if not output_file:
                self.procesando = False
                self.btn_select.configure(text="ğŸ“ Seleccionar Carpeta de ImÃ¡genes")
                return
                
            # Start conversion in a thread
            thread = threading.Thread(
                target=self._convert_images,
                args=(directory, output_file)
            )
            thread.start()
            
        except Exception as e:
            self.procesando = False
            self.btn_select.configure(text="ğŸ“ Seleccionar Carpeta de ImÃ¡genes")
            messagebox.showerror(
                "Error",
                f"Error al procesar carpeta: {str(e)}"
            )
            
    def _convert_images(self, input_dir: str, output_file: str):
        """Convert images to PDF in a separate thread."""
        try:
            # Update progress callback
            def update_progress(current: int, total: int):
                progress = current / total
                self.progress_bar.set(progress)
                self.progress_label.configure(text=f"{int(progress * 100)}%")
                self._add_detail(f"Procesando archivo {current} de {total}")
                
            # Convert images
            self.image_processor.batch_convert_to_pdf(
                input_dir,
                output_file,
                "*",  # Pattern filter
                update_progress,
                self.modo_comprimido.get()
            )
            
            # Show success message
            messagebox.showinfo(
                "Ã‰xito",
                "ConversiÃ³n completada exitosamente"
            )
            
        except Exception as e:
            if isinstance(e, InterruptedError):
                messagebox.showinfo(
                    "Cancelado",
                    "ConversiÃ³n cancelada por el usuario"
                )
            else:
                messagebox.showerror(
                    "Error",
                    f"Error durante la conversiÃ³n: {str(e)}"
                )
                
        finally:
            self.procesando = False
            self.btn_select.configure(text="ğŸ“ Seleccionar Carpeta de ImÃ¡genes")
            
    def _add_detail(self, text: str):
        """Add text to details area."""
        self.details_text.configure(state="normal")
        self.details_text.insert("end", text + "\n")
        self.details_text.see("end")
        self.details_text.configure(state="disabled")
        
    def _add_folder_detail(self, text: str):
        """Add text to folders details area."""
        self.folders_details_text.configure(state="normal")
        self.folders_details_text.insert("end", text + "\n")
        self.folders_details_text.see("end")
        self.folders_details_text.configure(state="disabled")
        
    def run(self):
        """Start the application."""
        self.mainloop()

```

## src\__init__.py
```


```

## src\utils\__init__.py
```


```

## src\utils\helpers.py
```
import os
from datetime import datetime
import time

def agregar_detalle(text_widget, mensaje, tipo="info"):
    """Agregar mensaje al widget de detalles"""
    prefijos = {
        "info": "â„¹ï¸",
        "error": "âŒ",
        "success": "âœ…",
        "warning": "âš ï¸"
    }
    prefijo = prefijos.get(tipo, "")
    timestamp = datetime.now().strftime("%H:%M:%S")
    text_widget.insert("end", f"[{timestamp}] {prefijo} {mensaje}\n")
    text_widget.see("end")

def actualizar_progreso(progressbar, valor):
    """Actualizar barra de progreso"""
    if hasattr(progressbar, 'set'):
        progressbar.set(valor)
    else:
        progressbar['value'] = valor * 100

def generar_nombre_zip():
    """Generar nombre para archivo ZIP"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    counter = getattr(generar_nombre_zip, '_counter', 0)
    generar_nombre_zip._counter = counter + 1
    return f"PDFs_{timestamp}_{counter}.zip"

def validar_directorio(directorio):
    """Validar que el directorio existe y tiene permisos"""
    if not os.path.exists(directorio):
        return False, "El directorio no existe"
    if not os.path.isdir(directorio):
        return False, "La ruta no es un directorio"
    if not os.access(directorio, os.R_OK | os.W_OK):
        return False, "No hay permisos suficientes en el directorio"
    return True, ""

```

## ROADMAP.md
```
# Roadmap de OptimizaciÃ³n - Imagen a PDF

## VisiÃ³n General
Este documento describe el plan de optimizaciÃ³n y mejoras para la aplicaciÃ³n de conversiÃ³n de imÃ¡genes a PDF. El objetivo es mejorar el rendimiento, la experiencia del usuario y agregar nuevas caracterÃ­sticas.

## Diagrama de Fases
```mermaid
graph TB
    subgraph "Fase 1: OptimizaciÃ³n de Procesamiento"
        A[1.1 Implementar Thread Pool] --> B[1.2 Optimizar BÃºsqueda de Archivos]
        B --> C[1.3 Mejorar GestiÃ³n de Memoria]
    end
    
    subgraph "Fase 2: Mejoras de UI"
        D[2.1 Sistema de CachÃ©] --> E[2.2 CancelaciÃ³n de Operaciones]
        E --> F[2.3 Optimizar Actualizaciones UI]
    end
    
    subgraph "Fase 3: CaracterÃ­sticas Avanzadas"
        G[3.1 CompresiÃ³n Configurable] --> H[3.2 Historial de Operaciones]
        H --> I[3.3 Procesamiento por Lotes]
    end
    
    C --> D
    F --> G
```

## Fase 1: OptimizaciÃ³n de Procesamiento
**DuraciÃ³n Estimada: 1-2 dÃ­as**

### 1.1 Implementar Thread Pool
- [x] Crear sistema de procesamiento paralelo
- [x] Configurar nÃºmero Ã³ptimo de workers
- [x] Implementar manejo de errores
- [x] Pruebas de rendimiento

### 1.2 Optimizar BÃºsqueda de Archivos
- [x] Migrar de os.walk a pathlib
- [x] Implementar filtrado eficiente
- [x] Agregar soporte para patrones personalizados
- [x] Documentar mejoras de rendimiento

### 1.3 Mejorar GestiÃ³n de Memoria
- [x] Implementar procesamiento por lotes
- [x] Optimizar carga de imÃ¡genes
- [x] Agregar lÃ­mites de memoria configurables
- [x] Monitoreo de uso de memoria

## Fase 2: Mejoras de UI
**DuraciÃ³n Estimada: 1-2 dÃ­as**

### 2.1 Sistema de CachÃ©
- [x] Implementar cachÃ© de directorios recientes
- [x] Agregar cachÃ© de configuraciones
- [x] Optimizar acceso a archivos frecuentes
- [x] GestiÃ³n de cachÃ© (limpieza automÃ¡tica)

### 2.2 CancelaciÃ³n de Operaciones
- [x] Agregar botÃ³n de cancelaciÃ³n
- [x] Implementar limpieza de recursos
- [x] Mejorar feedback al usuario
- [x] Pruebas de cancelaciÃ³n

### 2.3 Optimizar Actualizaciones UI
- [x] Reducir frecuencia de actualizaciones
- [x] Implementar buffer de eventos
- [x] Mejorar animaciones y transiciones
- [x] Pruebas de rendimiento UI

## Fase 3: CaracterÃ­sticas Avanzadas
**DuraciÃ³n Estimada: 2-3 dÃ­as**

### 3.1 CompresiÃ³n Configurable
- [ ] Agregar opciones de compresiÃ³n
- [ ] Implementar presets de calidad
- [ ] Optimizar tamaÃ±o de salida
- [ ] DocumentaciÃ³n de opciones

### 3.2 Historial de Operaciones
- [ ] Crear registro de conversiones
- [ ] Implementar sistema de logs
- [ ] Agregar estadÃ­sticas de uso
- [ ] Interfaz de visualizaciÃ³n de historial

### 3.3 Procesamiento por Lotes
- [ ] Agregar cola de procesamiento
- [ ] Implementar prioridades
- [ ] Optimizar recursos del sistema
- [ ] Pruebas de carga

## Prioridades y Dependencias

### Alta Prioridad
- Thread Pool (mejora inmediata de rendimiento)
- CancelaciÃ³n de Operaciones (mejor UX)
- GestiÃ³n de Memoria (estabilidad)

### Media Prioridad
- Sistema de CachÃ© (optimizaciÃ³n)
- OptimizaciÃ³n de UI (experiencia de usuario)
- BÃºsqueda de Archivos (eficiencia)

### Baja Prioridad
- CompresiÃ³n Configurable (caracterÃ­stica adicional)
- Historial (caracterÃ­stica adicional)
- Procesamiento por Lotes (escalabilidad)

## MÃ©tricas de Ã‰xito

### Rendimiento
- ReducciÃ³n del tiempo de procesamiento en 60-70%
- ReducciÃ³n del uso de memoria en 40-50%
- Mejora en la respuesta de la UI

### Experiencia de Usuario
- ReducciÃ³n de tiempo de espera
- Mayor control sobre el proceso
- Mejor feedback visual

### Calidad
- Cobertura de pruebas > 80%
- Cero errores crÃ­ticos
- DocumentaciÃ³n completa

## Seguimiento de Progreso

### Estado Actual
- [x] Fase 1 completada
- [x] Fase 2 completada
- [ ] Fase 3 completada

### PrÃ³ximos Pasos
1. Iniciar implementaciÃ³n de CompresiÃ³n Configurable
2. Realizar pruebas de rendimiento base
3. Documentar mejoras iniciales

## Notas
- Las fechas son estimativas y pueden ajustarse segÃºn el progreso
- Se realizarÃ¡n revisiones semanales del progreso
- Se priorizarÃ¡ la estabilidad sobre nuevas caracterÃ­sticas

```

## scripts\create_simple_icon.py
```
from PIL import Image, ImageDraw
import os

def create_icon():
    # Crear una imagen base con fondo transparente
    size = (256, 256)
    icon = Image.new('RGBA', size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(icon)
    
    # Colores
    azul = (33, 150, 243)  # Material Blue
    blanco = (255, 255, 255)
    
    # Dibujar un cÃ­rculo azul como fondo
    padding = 20
    circle_bbox = (padding, padding, size[0]-padding, size[1]-padding)
    draw.ellipse(circle_bbox, fill=azul)
    
    # Dibujar el sÃ­mbolo de imagen (un rectÃ¡ngulo con una montaÃ±a)
    margin = 60
    img_box = (margin, margin, size[0]-margin, size[1]-margin)
    draw.rectangle(img_box, fill=blanco)
    
    # Dibujar la "montaÃ±a" dentro del rectÃ¡ngulo
    peak_height = margin + (size[1]-2*margin) * 0.3
    mountain_points = [
        (margin, size[1]-margin),  # Esquina inferior izquierda
        (margin + (size[0]-2*margin) * 0.4, peak_height),  # Primer pico
        (margin + (size[0]-2*margin) * 0.7, peak_height + 30),  # Segundo pico
        (size[0]-margin, size[1]-margin)  # Esquina inferior derecha
    ]
    draw.polygon(mountain_points, fill=azul)
    
    # Dibujar el sÃ­mbolo PDF en la esquina inferior derecha
    pdf_size = 80
    pdf_margin = 40
    pdf_box = (
        size[0] - pdf_size - pdf_margin,
        size[1] - pdf_size - pdf_margin,
        size[0] - pdf_margin,
        size[1] - pdf_margin
    )
    draw.rectangle(pdf_box, fill=azul)
    
    # Texto "PDF" en blanco
    pdf_text_margin = 45
    draw.text(
        (size[0] - pdf_size - pdf_margin + 15, size[1] - pdf_size - pdf_margin + 20),
        "PDF",
        fill=blanco,
        font=None
    )
    
    # Guardar en diferentes tamaÃ±os
    sizes = [(256, 256), (128, 128), (64, 64), (48, 48), (32, 32), (16, 16)]
    images = []
    
    for s in sizes:
        resized = icon.resize(s, Image.Resampling.LANCZOS)
        images.append(resized)
    
    # Eliminar icono existente si existe
    if os.path.exists('icon.ico'):
        os.remove('icon.ico')
    
    # Guardar como ICO
    icon.save('icon.ico', format='ICO', sizes=sizes)
    print("Icono creado exitosamente")

if __name__ == '__main__':
    create_icon()

```

## scripts\create_icon.py
```
from PIL import Image
import os

def create_icon():
    # Primero vamos a crear una imagen base limpia con el diseÃ±o que queremos
    size = (256, 256)  # TamaÃ±o base mÃ¡s pequeÃ±o para mejor calidad
    icon = Image.new('RGBA', size, (0, 0, 0, 0))
    
    # Cargar la imagen original
    input_path = "DALLÂ·E 2024-12-23 12.09.15 - A modern icon in the style of Material Design, representing image-to-PDF conversion. The design includes an image icon (a rectangle with a mountain an.webp"
    img = Image.open(input_path)
    
    # Convertir a RGBA
    if img.mode != 'RGBA':
        img = img.convert('RGBA')
    
    # Redimensionar la imagen original manteniendo la proporciÃ³n
    img.thumbnail(size, Image.Resampling.LANCZOS)
    
    # Calcular la posiciÃ³n para centrar la imagen
    x = (size[0] - img.size[0]) // 2
    y = (size[1] - img.size[1]) // 2
    
    # Pegar la imagen centrada
    icon.paste(img, (x, y), img)
    
    # Guardar primero como PNG de alta calidad
    icon.save('temp_icon.png', 'PNG')
    
    # Ahora crear las diferentes versiones para el ICO
    sizes = [
        (256, 256),
        (128, 128),
        (64, 64),
        (48, 48),
        (32, 32),
        (16, 16)
    ]
    
    # Lista para almacenar las imÃ¡genes
    images = []
    
    # Cargar el PNG temporal que acabamos de crear
    base_img = Image.open('temp_icon.png')
    
    for size in sizes:
        # Crear una nueva imagen con fondo transparente
        img = Image.new('RGBA', size, (0, 0, 0, 0))
        
        # Redimensionar la imagen base
        resized = base_img.resize(size, Image.Resampling.LANCZOS)
        
        # Pegar en el centro
        img.paste(resized, (0, 0), resized)
        
        images.append(img)
    
    # Eliminar el archivo ico si ya existe
    if os.path.exists('icon.ico'):
        os.remove('icon.ico')
    
    # Guardar como ICO
    images[0].save(
        'icon.ico',
        format='ICO',
        sizes=[(img.size[0], img.size[1]) for img in images]
    )
    
    # Limpiar el archivo temporal
    if os.path.exists('temp_icon.png'):
        os.remove('temp_icon.png')
    
    print("Icono creado exitosamente")

if __name__ == '__main__':
    create_icon()

```

## requirements.txt
```
# Dependencias principales
Pillow>=10.3.0  # Actualizado por vulnerabilidad de seguridad en ImageMath.eval
customtkinter>=5.2.2
pathlib>=1.0.1
pandas
openpyxl

# Dependencias de desarrollo
pytest>=8.3.4
coverage>=7.3.0
pylint>=3.3.3

```

## README.md
```
# ImagenToPDF

AplicaciÃ³n para convertir imÃ¡genes a PDF de forma rÃ¡pida y eficiente.

## CaracterÃ­sticas

- ConversiÃ³n rÃ¡pida de imÃ¡genes a PDF usando procesamiento paralelo
- Soporte para mÃºltiples formatos de imagen:
  - PNG, JPG, JPEG, BMP, TIFF, WEBP, GIF, HEIC, HEIF
  - Manejo case-insensitive de extensiones (*.jpg, *.JPG, etc.)
- Filtrado de imÃ¡genes por patrones personalizados (ej: `foto_*.jpg`, `*.png`)
- Interfaz grÃ¡fica moderna e intuitiva
- OpciÃ³n para generar archivo ZIP con los PDFs
- Manejo eficiente de memoria para imÃ¡genes grandes
- Soporte para cancelaciÃ³n de operaciones
- **CreaciÃ³n de carpetas desde plantillas Excel**
  - NormalizaciÃ³n automÃ¡tica de nombres de carpetas
  - Soporte para mÃºltiples columnas (ID, Nombres, Apellidos)
  - Manejo de nombres duplicados y caracteres especiales

## Requisitos

- Python 3.8 o superior
- Pillow >= 10.3.0 (Importante: versiÃ³n mÃ­nima por seguridad)
- CustomTkinter >= 5.2.2
- Threading

## Seguridad

Este proyecto se mantiene actualizado con las Ãºltimas correcciones de seguridad. La versiÃ³n mÃ­nima de Pillow (10.3.0) es requerida para prevenir una vulnerabilidad de ejecuciÃ³n de cÃ³digo arbitrario en PIL.ImageMath.eval.

## InstalaciÃ³n

1. Clona el repositorio:
```bash
git clone https://github.com/tuusuario/imagenTopdf.exe.git
```

2. Instala las dependencias:
```bash
pip install -r requirements.txt
```

## Uso

1. Ejecuta la aplicaciÃ³n:
```bash
python src/app/main.py
```

2. Usa la interfaz grÃ¡fica para:
   - Seleccionar la carpeta con imÃ¡genes
   - Aplicar filtros por patrÃ³n (opcional)
   - Elegir si deseas generar un ZIP
   - Iniciar la conversiÃ³n

### Filtros de BÃºsqueda

Puedes usar patrones para filtrar las imÃ¡genes que deseas convertir:
- `*.jpg` - Todas las imÃ¡genes JPG
- `foto_*.png` - ImÃ¡genes PNG que empiecen con "foto_"
- `IMG_20*.jpg` - Fotos JPG que empiecen con "IMG_20"

### CreaciÃ³n de Carpetas desde Excel

Puedes crear carpetas de forma automÃ¡tica usando una plantilla Excel:

```python
from src.core.folder_creator import FolderCreator

# Inicializar creador de carpetas
folder_creator = FolderCreator()

# Procesar plantilla Excel
exito, mensaje = folder_creator.procesar_plantilla(
    'ruta/a/tu/plantilla.xlsx', 
    'directorio/de/salida'
)

# Manejar callbacks (opcional)
class MisCallbacks:
    def on_folder_created(self, nombre_carpeta):
        print(f"Carpeta creada: {nombre_carpeta}")
    
    def on_folder_exists(self, nombre_carpeta):
        print(f"Carpeta ya existente: {nombre_carpeta}")

# Procesar con callbacks
folder_creator.procesar_plantilla(
    'ruta/a/tu/plantilla.xlsx', 
    'directorio/de/salida',
    MisCallbacks()
)
```

### Formato de Plantilla Excel

La plantilla debe contener al menos las columnas:
- `ID`: Identificador Ãºnico
- `NOMBRES`: Nombre de la persona o entidad
- Opcional: `APELLIDOS`: Apellidos para nombres mÃ¡s completos

## Desarrollo

### Estructura del Proyecto
```
imagenTopdf.exe/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ app/
â”‚       â”œâ”€â”€ main.py
â”‚       â”œâ”€â”€ gui.py
â”‚       â””â”€â”€ pdf_converter.py
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_pdf_converter.py
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ README.md
â””â”€â”€ ROADMAP.md
```

### Pruebas

Ejecuta las pruebas unitarias:
```bash
python -m unittest tests/test_pdf_converter.py -v
```

## Contribuir

1. Haz un Fork del proyecto
2. Crea una rama para tu caracterÃ­stica (`git checkout -b feature/AmazingFeature`)
3. Haz commit de tus cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abre un Pull Request

## Licencia

Este proyecto estÃ¡ bajo la Licencia MIT - ver el archivo [LICENSE](LICENSE) para mÃ¡s detalles.

```

## main.py
```
"""
Main entry point for the PDF converter application.
"""
import sys
from pathlib import Path

# Add src directory to Python path
sys.path.insert(0, str(Path(__file__).parent))

from src.app.gui import ImagenAPdfGUI

def main():
    """Punto de entrada principal de la aplicaciÃ³n"""
    app = ImagenAPdfGUI()
    app.iniciar()

if __name__ == "__main__":
    main()

```

## imagen_a_pdf.py
```
print("Iniciando aplicaciÃ³n...")

import os
import customtkinter as ctk
from PIL import Image
from tkinter import filedialog, messagebox
import threading
import zipfile
from datetime import datetime
import shutil
import tempfile
import pandas as pd
import openpyxl
from openpyxl import Workbook

class ImagenAPdfApp:
    def __init__(self):
        # ConfiguraciÃ³n de la ventana principal
        self.ventana = ctk.CTk()
        self.ventana.title("Herramientas de Productividad")
        self.ventana.geometry("500x500")  # Reducimos significativamente la altura
        self.ventana.resizable(False, False)  # Bloqueamos el redimensionamiento
        
        # Configurar el tema
        ctk.set_appearance_mode("system")
        ctk.set_default_color_theme("blue")
        
        # Variables de control
        self.procesando = False
        self.modo_comprimido = ctk.BooleanVar(value=False)
        self.directorio_salida = None
        
        # Crear el contenido de la ventana
        self.crear_widgets()

    def iniciar(self):
        # Iniciar el mainloop
        self.ventana.mainloop()

    def crear_widgets(self):
        # Preparar la estructura para agregar pestaÃ±as
        self.notebook = ctk.CTkTabview(self.ventana)
        self.notebook.pack(pady=20, padx=20, fill="both", expand=True)
        
        # Agregar pestaÃ±as en el orden deseado
        self.pestaÃ±a_carpetas = self.notebook.add("Crear Carpetas")  # Primera pestaÃ±a
        self.pestaÃ±a_principal = self.notebook.add("imagenes a PDFs")     # Segunda pestaÃ±a
        
        # Crear contenido de las pestaÃ±as
        self.crear_contenido_pestaÃ±a_carpetas()
        self.crear_contenido_pestaÃ±a_principal()
        

    def crear_contenido_pestaÃ±a_carpetas(self):
        # Frame principal con padding mÃ­nimo
        frame = ctk.CTkFrame(self.pestaÃ±a_carpetas)
        frame.pack(pady=10, padx=10, fill="both", expand=True)
        
        # TÃ­tulo
        titulo = ctk.CTkLabel(frame, text="CreaciÃ³n Masiva de Carpetas", 
                            font=ctk.CTkFont(size=20, weight="bold"))
        titulo.pack(pady=5)

        # DescripciÃ³n
        descripcion1 = ctk.CTkLabel(frame, 
            text="Descarga la plantilla Excel, completa los datos con ID, NOMBRES y APELLIDOS.",
            font=ctk.CTkFont(size=12),
            text_color="#CCCCCC"
        )
        descripcion1.pack(pady=2)

        descripcion2 = ctk.CTkLabel(frame, 
            text="Luego, carga el archivo para crear automÃ¡ticamente las carpetas.",
            font=ctk.CTkFont(size=12),
            text_color="#CCCCCC"
        )
        descripcion2.pack(pady=(0,5))
        
        # Frame para la primera fila (plantilla y carga)
        fila1_frame = ctk.CTkFrame(frame)
        fila1_frame.pack(fill="x", padx=10, pady=10)
        
        # Columna izquierda: Descargar plantilla
        btn_descargar = ctk.CTkButton(
            fila1_frame,
            text="ğŸ“¥ Descargar Plantilla",
            command=self.descargar_plantilla
        )
        btn_descargar.pack(side="left", padx=5)
        
        # Columna derecha: Cargar plantilla
        btn_cargar = ctk.CTkButton(
            fila1_frame,
            text="ğŸ“¤ Cargar Plantilla",
            command=self.cargar_plantilla
        )
        btn_cargar.pack(side="right", padx=5)
        
        # Etiqueta de estado
        self.estado_carpetas_label = ctk.CTkLabel(frame, 
            text="Estado: Esperando plantilla...",
            font=ctk.CTkFont(size=12)
        )
        self.estado_carpetas_label.pack(pady=10)
        
        # Ãrea de detalles para la creaciÃ³n de carpetas
        self.detalles_carpetas_text = ctk.CTkTextbox(frame, height=100)
        self.detalles_carpetas_text.pack(fill="x", padx=10, pady=(5,10))
        self.detalles_carpetas_text.configure(state="disabled")

        # Agregar footer
        self.crear_footer(frame)
        
    def crear_contenido_pestaÃ±a_principal(self):
        # Frame principal con padding mÃ­nimo
        frame = ctk.CTkFrame(self.pestaÃ±a_principal)
        frame.pack(pady=10, padx=10, fill="both", expand=True)

        # TÃ­tulo
        titulo = ctk.CTkLabel(frame, text="Conversor de ImÃ¡genes a PDF", 
                            font=ctk.CTkFont(size=20, weight="bold"))
        titulo.pack(pady=5)

        # Checkbox para comprimir
        self.cb_comprimir = ctk.CTkCheckBox(
            frame,
            text="Generar archivos PDFs en un nuevo archivo ZIP",
            variable=self.modo_comprimido,
            onvalue=True,
            offvalue=False
        )
        self.cb_comprimir.pack(pady=10)

        # BotÃ³n para seleccionar carpeta
        self.btn_seleccionar = ctk.CTkButton(
            frame,
            text="ğŸ“ Seleccionar Carpeta de ImÃ¡genes",
            command=self.seleccionar_carpeta
        )
        self.btn_seleccionar.pack(pady=10)

        # Barra de progreso
        self.barra_progreso = ctk.CTkProgressBar(frame)
        self.barra_progreso.pack(fill="x", padx=10, pady=5)
        self.barra_progreso.set(0)

        # Etiqueta de progreso
        self.progreso_label = ctk.CTkLabel(frame, text="0%")
        self.progreso_label.pack(pady=5)

        # Etiqueta de estado
        self.estado_label = ctk.CTkLabel(
            frame,
            text="Estado: Esperando selecciÃ³n de carpeta...",
            font=ctk.CTkFont(size=12)
        )
        self.estado_label.pack(pady=5)

        # Ãrea de detalles
        self.detalles_text = ctk.CTkTextbox(frame, height=75)
        self.detalles_text.pack(fill="x", padx=10, pady=(5,10))
        self.detalles_text.configure(state="disabled")

        # Agregar footer
        self.crear_footer(frame)

    def crear_footer(self, frame_padre):
        # Frame interno para los crÃ©ditos
        creditos_interno = ctk.CTkFrame(frame_padre, fg_color="transparent")
        creditos_interno.pack(side="bottom", fill="x", pady=(10, 3))

        # Primera lÃ­nea: Desarrollador y aÃ±o
        creditos_linea1 = ctk.CTkLabel(
            creditos_interno,
            text="Desarrollado por: Luis Fernando Moreno Montoya | 2024",
            font=ctk.CTkFont(size=13),
            text_color="#CCCCCC"
        )
        creditos_linea1.pack(pady=(10, 3))
        
        # Segunda lÃ­nea: Mensaje especial (dividido en partes para colorear el corazÃ³n)
        mensaje_frame = ctk.CTkFrame(creditos_interno, fg_color="transparent")
        mensaje_frame.pack(pady=(3, 10))

        # Primera parte del mensaje
        parte1 = ctk.CTkLabel(
            mensaje_frame,
            text="Hecho con ",
            font=ctk.CTkFont(size=13),
            text_color="#CCCCCC"
        )
        parte1.pack(side="left")

        # CorazÃ³n en rojo
        corazon = ctk.CTkLabel(
            mensaje_frame,
            text="â™¥",
            font=ctk.CTkFont(size=13),
            text_color="#FF0000"
        )
        corazon.pack(side="left")

        # Segunda parte del mensaje
        parte2 = ctk.CTkLabel(
            mensaje_frame,
            text=" por la productividad laboral y el cuidado del tiempo",
            font=ctk.CTkFont(size=13),
            text_color="#CCCCCC"
        )
        parte2.pack(side="left")
        
        return creditos_interno

    def descargar_plantilla(self):
        try:
            # Crear un nuevo libro de Excel
            wb = Workbook()
            ws = wb.active
            
            # Configurar encabezados
            ws['A1'] = 'ID'
            ws['B1'] = 'NOMBRES'
            ws['C1'] = 'APELLIDOS'
            
            # Pedir al usuario donde guardar la plantilla
            ruta_guardado = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                filetypes=[("Excel files", "*.xlsx")],
                title="Guardar plantilla como",
                initialfile="Plantilla Nombres Carpetas"
            )
            
            if ruta_guardado:
                wb.save(ruta_guardado)
                messagebox.showinfo("Ã‰xito", "Plantilla descargada correctamente")
        except Exception as e:
            messagebox.showerror("Error", f"Error al crear la plantilla: {str(e)}")

    def cargar_plantilla(self):
        try:
            # Pedir al usuario la plantilla Excel
            ruta_excel = filedialog.askopenfilename(
                filetypes=[("Excel files", "*.xlsx")],
                title="Seleccionar plantilla Excel"
            )
            
            if not ruta_excel:
                return
                
            # Pedir al usuario el directorio donde crear las carpetas
            directorio_destino = filedialog.askdirectory(
                title="Seleccionar directorio para crear carpetas"
            )
            
            if not directorio_destino:
                return
            
            # Leer el Excel
            df = pd.read_excel(ruta_excel)
            
            # Verificar columnas requeridas
            columnas_requeridas = ['ID', 'NOMBRES', 'APELLIDOS']
            if not all(col in df.columns for col in columnas_requeridas):
                messagebox.showerror("Error", "La plantilla no tiene el formato correcto")
                return
            
            # Crear carpetas
            carpetas_creadas = 0
            self.detalles_carpetas_text.configure(state="normal")
            self.detalles_carpetas_text.delete("1.0", "end")
            
            for _, row in df.iterrows():
                try:
                    nombre_carpeta = f"{row['ID']} - {row['NOMBRES']} {row['APELLIDOS']}"
                    ruta_carpeta = os.path.join(directorio_destino, nombre_carpeta)
                    
                    if not os.path.exists(ruta_carpeta):
                        os.makedirs(ruta_carpeta)
                        carpetas_creadas += 1
                        self.detalles_carpetas_text.insert("end", f"âœ“ Creada: {nombre_carpeta}\n")
                    else:
                        self.detalles_carpetas_text.insert("end", f"âš  Ya existe: {nombre_carpeta}\n")
                except Exception as e:
                    self.detalles_carpetas_text.insert("end", f"âœ— Error al crear {nombre_carpeta}: {str(e)}\n")
            
            self.detalles_carpetas_text.configure(state="disabled")
            self.estado_carpetas_label.configure(text=f"Estado: {carpetas_creadas} carpetas creadas")
            
            messagebox.showinfo("Completado", f"Se han creado {carpetas_creadas} carpetas")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al procesar la plantilla: {str(e)}")

    def seleccionar_carpeta(self):
        if self.procesando:
            messagebox.showwarning("En proceso", "Por favor espera a que termine el proceso actual")
            return
            
        carpeta = filedialog.askdirectory(title="Selecciona la carpeta con imÃ¡genes")
        if carpeta:
            # Si es modo comprimido, pedir ubicaciÃ³n del ZIP
            if self.modo_comprimido.get():
                fecha_actual = datetime.now().strftime("%Y%m%d_%H%M%S")
                nombre_zip = f"PDFs_Convertidos_{fecha_actual}.zip"
                self.directorio_salida = filedialog.asksaveasfilename(
                    defaultextension=".zip",
                    initialfile=nombre_zip,
                    title="Guardar archivo ZIP como",
                    filetypes=[("Archivo ZIP", "*.zip")]
                )
                if not self.directorio_salida:
                    return
            
            # Iniciar proceso en un hilo separado
            thread = threading.Thread(target=self.procesar_carpeta, args=(carpeta,))
            thread.daemon = True
            thread.start()
    
    def procesar_carpeta(self, directorio):
        """Procesa todas las imÃ¡genes en la carpeta"""
        temp_dir = None
        try:
            self.procesando = True
            self.btn_seleccionar.configure(state="disabled")
            self.estado_label.configure(text="Estado: Buscando imÃ¡genes...")
            
            # Crear directorio temporal si es modo comprimido
            if self.modo_comprimido.get():
                temp_dir = tempfile.mkdtemp()
            
            # Encontrar todas las imÃ¡genes
            imagenes = []
            for ruta_actual, _, archivos in os.walk(directorio):
                for archivo in archivos:
                    if archivo.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.tiff')):
                        imagenes.append(os.path.join(ruta_actual, archivo))
            
            if not imagenes:
                messagebox.showinfo("InformaciÃ³n", "No se encontraron imÃ¡genes en la carpeta seleccionada")
                self.reset_interfaz()
                return
            
            total_imagenes = len(imagenes)
            convertidas = 0
            errores = 0
            
            self.barra_progreso.set(0)
            self.agregar_detalle(f"Encontradas {total_imagenes} imÃ¡genes para convertir")
            
            for ruta_imagen in imagenes:
                try:
                    nombre_archivo = os.path.basename(ruta_imagen)
                    self.estado_label.configure(text=f"Estado: Procesando {nombre_archivo}")
                    
                    # Determinar ruta de salida
                    if self.modo_comprimido.get():
                        # Mantener la estructura de directorios dentro del ZIP
                        ruta_relativa = os.path.relpath(ruta_imagen, directorio)
                        ruta_pdf = os.path.join(temp_dir, os.path.splitext(ruta_relativa)[0] + ".pdf")
                        # Crear directorios necesarios
                        os.makedirs(os.path.dirname(ruta_pdf), exist_ok=True)
                    else:
                        ruta_pdf = os.path.splitext(ruta_imagen)[0] + ".pdf"
                    
                    with Image.open(ruta_imagen) as img:
                        if img.mode != 'RGB':
                            img = img.convert('RGB')
                        img.save(ruta_pdf, "PDF")
                    
                    convertidas += 1
                    progreso = (convertidas / total_imagenes)
                    self.barra_progreso.set(progreso)
                    self.progreso_label.configure(text=f"{int(progreso * 100)}%")
                    self.agregar_detalle(f"âœ“ Convertido: {nombre_archivo}")
                    
                except Exception as e:
                    errores += 1
                    self.agregar_detalle(f"âœ— Error al convertir {nombre_archivo}: {str(e)}")
                
                self.ventana.update()
            
            # Si es modo comprimido, crear el ZIP
            if self.modo_comprimido.get() and temp_dir:
                self.estado_label.configure(text="Estado: Creando archivo ZIP...")
                self.agregar_detalle("Creando archivo ZIP...")
                
                with zipfile.ZipFile(self.directorio_salida, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for root, _, files in os.walk(temp_dir):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, temp_dir)
                            zipf.write(file_path, arcname)
                
                self.agregar_detalle(f"âœ“ Archivo ZIP creado en: {self.directorio_salida}")
            
            # Mostrar resumen final
            mensaje = f"Proceso completado\nImÃ¡genes convertidas: {convertidas}/{total_imagenes}"
            if errores > 0:
                mensaje += f"\nErrores encontrados: {errores}"
            if self.modo_comprimido.get():
                mensaje += f"\nArchivo ZIP creado en:\n{self.directorio_salida}"
            
            messagebox.showinfo("Completado", mensaje)
            self.estado_label.configure(text="Estado: Proceso completado")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error inesperado: {str(e)}")
        finally:
            # Limpiar directorio temporal si existe
            if temp_dir and os.path.exists(temp_dir):
                shutil.rmtree(temp_dir)
            self.reset_interfaz()
    
    def reset_interfaz(self):
        """Resetea la interfaz a su estado inicial"""
        self.procesando = False
        self.btn_seleccionar.configure(state="normal")
        self.ventana.update()
    
    def agregar_detalle(self, texto):
        """Agrega texto al Ã¡rea de detalles"""
        self.detalles_text.configure(state="normal")
        self.detalles_text.insert("end", texto + "\n")
        self.detalles_text.see("end")
        self.detalles_text.configure(state="disabled")
        self.ventana.update()



if __name__ == "__main__":
    app = ImagenAPdfApp()
    app.iniciar()

```

## icon.py
```
import base64
from PIL import Image
import io

# Icono en base64 (un icono simple de PDF)
ICON = b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU9TpUUqDnYQcchQnSyIijhKFYtgobQVWnUweekfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfE0clJ0UVKvC8ptIjxwuN9nHfP4b37AKFWYprVNgZoum2mEnExk10RQ68IIoQ+9GJYZpYxK0lJ+NbXPXVT3cV4ln/fn9Wt5iwGBETiGWaYNvE68dSmbXDeJ46woqwSnxOPmnRB4keuKx6/cS64LPDMiJlOzRFHiMVCCystzIqmRjxJHFU1nfKFjMcq5y3OWqnCGvfkLwzn9OUlrtMaQgILWIQEEQoq2EAJNmK066RYSNF53Mc/4Polcink2gAjxzzK0CC7fvA/+D1bKz8x7iWF40D7i+N8DAOhXaBedZzvY8epnwDBZ+BKb/rLNWD6k/RqU4seAT3bwMV1U1P2gMsdoP/JkE3ZlYK0hHweeD+jb8oC/bdA16rXW2Mfpw9AhrpK3QAHh8BIHrLXW/w7Z3X3zZM13/cA0mRyofl0OnwAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfoAhcVNhKd6zRtAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAA0BJREFUWMPtV0FrE1EQnnlv3+4mm4SEJGvXJA2NbU3E4kHBgwUP4kHx4kHwIp48efAkePGiIOLNP+BBUDyICIIXQVCKtqiIjbXaNqVNE5PNZrO72ffGg7XY5m3ebnYF8Qv7IGTfzrczb2a+GYAgQXgH5Q/rw7nQxwsvt5+VFwFQBEGQAIANAOD/5QRYlp2bnV1aXVl5VKvVFliWpQEAUBQFOY4Dh4eHkMvlYH9/f8TzvLtjY2Ofx8fHvxQKBT+VSrWPj4+/jY6O1hzHgWg0egYAzjRN03ccB0RRhEgkAoIggGEYEA6HQZIkiMViIAgCKIoCmqaBLMsgyzKk02lYX19/XC6X78/Pz7/L5/Pfz4jYbDYhFAqBaZoQiUQgHA6DJEkgiiKwLAuCIADHcUDTNFAUBYqiAE3TwHEcsCwLPM+DZVlgWRY4jgOu64Jt2+A4DhiGAZ7nQa1WA9/3wXEcqNfr0Gg0QJZlkGUZVFUFVVWhUqnA1tbWzYWFhVvn7gDLspBMJiEUCoEoihAOh0EQBOB5HhiGAZqmgaIoIAgCKIoCmqaBYRhgWRYEQQCO44DneWBZFjiOA9d1wbZtcBwHDMMAz/PA932wbRsajQY0m01wXRcMwwBVVUFRFNjZ2bm+uLh4/dwdkGUZYrEYiKIIsiwDz/PA8zwwDAM0TQNFUUAQBFAUBTRNw8nJCTQaDXAcBzzPA8dxwLZtaDab4DgOGIYBnueBbdtgWRZYlgWu64JhGFCv16FarUKlUoFyuQzb29sTZ0RomoZEIgGxWAxEUQSe54HjOKBpGiiKAoIggKIooGkaKIoCmqaB4zhgWfaUiOd54DgO2LYNruuCZVlgmiZ4nge2bYNpmqDrOlSrVahUKrC3twc7OztT8/PzL4aGhj4MDw9/zGQyB4ODg58ymczngYGBg3Q6XUkmk/V4PO7F43EvkUh4qVTKS6fTXjab9fr6+rxcLuf19/d7uVzOGxgY8AYHBz0AABYAYHNz89r09PTz/v7+90NDQx/7+vreZbPZt9ls9vXAwMDLbDb7rLe391kqlXqSSCQe9/T03I3H43c6OztvR6PRW6Io3hQE4QbP89dYlp1kGGaCpukxiqJGSZIcIQhihCCIYYIghgiCyBAE0U0QRBdBEEn6F/EdP4Nm6T9JR7IAAAAASUVORK5CYII='

# Convertir el icono base64 a archivo
icon_data = base64.b64decode(ICON)
icon = Image.open(io.BytesIO(icon_data))
icon.save('icon.ico')

```

## CHANGELOG.md
```
# Registro de Cambios

## [1.2.1] - 2024-12-24

### Seguridad
- Actualizada la dependencia de Pillow a >=10.3.0 para corregir una vulnerabilidad de seguridad en `PIL.ImageMath.eval`
- Mejorada la gestiÃ³n de dependencias con versiones especÃ­ficas

### Cambios
- Agregadas dependencias de desarrollo (pytest, coverage)
- Actualizada la documentaciÃ³n de requisitos
- Mejorada la estructura del archivo requirements.txt

## [1.2.0] - 2024-12-23

### Agregado
- Implementado soporte para patrones personalizados en la bÃºsqueda de imÃ¡genes
- Agregado manejo case-insensitive para extensiones de archivo
- Nuevos formatos de imagen soportados: HEIC, HEIF
- Tooltips informativos en la interfaz

### Optimizado
- Mejorado el rendimiento de bÃºsqueda de archivos
- Implementada bÃºsqueda case-insensitive eficiente
- Optimizado el manejo de memoria

### Corregido
- Solucionado problema con duplicados en la bÃºsqueda de archivos
- Mejorado el manejo de errores en la conversiÃ³n

## [1.1.0] - 2024-12-22

### Agregado
- Implementado procesamiento paralelo con ThreadPool
- Agregada funcionalidad de cancelaciÃ³n de operaciones
- Mejorado el manejo de memoria para imÃ¡genes grandes

### Optimizado
- MigraciÃ³n a pathlib para manejo de rutas
- Mejorada la eficiencia en la bÃºsqueda de archivos

## [1.0.0] - 2024-12-21

### Inicial
- Lanzamiento inicial de la aplicaciÃ³n
- Interfaz grÃ¡fica bÃ¡sica
- Soporte para formatos principales de imagen
- ConversiÃ³n bÃ¡sica a PDF

```

## src\app\gui.py
```
import customtkinter as ctk
from tkinter import filedialog, messagebox
import os
from datetime import datetime
from .pdf_converter import PDFConverter
from src.core.folder_creator import FolderCreator
from ..utils.helpers import agregar_detalle, actualizar_progreso, generar_nombre_zip
import threading

class ImagenAPdfGUI:
    def __init__(self):
        # ConfiguraciÃ³n de la ventana principal
        self.ventana = ctk.CTk()
        self.ventana.title("Herramientas de Productividad")
        self.ventana.geometry("500x500")
        self.ventana.resizable(False, False)
        
        # Configurar el tema
        ctk.set_appearance_mode("system")
        ctk.set_default_color_theme("blue")
        
        # Variables de control
        self.procesando = False
        self.modo_comprimido = ctk.BooleanVar(value=False)
        self.directorio_salida = None
        self.patron_filtro = ctk.StringVar(value="*")
        
        # Inicializar componentes
        self.pdf_converter = PDFConverter()
        self.folder_creator = FolderCreator()
        
        # Crear interfaz
        self.crear_widgets()
    
    def crear_widgets(self):
        # Preparar la estructura para agregar pestaÃ±as
        self.notebook = ctk.CTkTabview(self.ventana)
        self.notebook.pack(pady=20, padx=20, fill="both", expand=True)
        
        # PestaÃ±as
        self.pestaÃ±a_carpetas = self.notebook.add("Crear Carpetas")
        self.pestaÃ±a_principal = self.notebook.add("imagenes a PDFs")
        
        # Crear contenido
        self.crear_contenido_pestaÃ±a_carpetas()
        self.crear_contenido_pestaÃ±a_principal()

    def crear_contenido_pestaÃ±a_carpetas(self):
        """Crear el contenido de la pestaÃ±a de creaciÃ³n de carpetas"""
        # TÃ­tulo y descripciÃ³n
        titulo = ctk.CTkLabel(
            self.pestaÃ±a_carpetas,
            text="Crear Carpetas desde Excel",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        titulo.pack(pady=(20, 10))

        descripcion = ctk.CTkLabel(
            self.pestaÃ±a_carpetas,
            text="1. Descarga la plantilla Excel\n2. Llena los datos y guarda el archivo",
            font=ctk.CTkFont(size=14)
        )
        descripcion.pack(pady=(0, 20))

        # Frame para botones
        botones_frame = ctk.CTkFrame(self.pestaÃ±a_carpetas, fg_color="transparent")
        botones_frame.pack(fill="x", padx=20)

        # BotÃ³n para descargar plantilla
        btn_plantilla = ctk.CTkButton(
            botones_frame,
            text="Descargar Plantilla",
            command=self.descargar_plantilla
        )
        btn_plantilla.pack(side="left", padx=5, expand=True)

        # BotÃ³n para crear carpetas
        btn_crear = ctk.CTkButton(
            botones_frame,
            text="Crear Carpetas",
            command=self.crear_carpetas
        )
        btn_crear.pack(side="left", padx=5, expand=True)

        # Ãrea de detalles
        self.detalles_carpetas = ctk.CTkTextbox(
            self.pestaÃ±a_carpetas,
            height=75
        )
        self.detalles_carpetas.pack(fill="both", expand=True, padx=20, pady=20)

        # Footer
        self.crear_footer(self.pestaÃ±a_carpetas)

    def crear_contenido_pestaÃ±a_principal(self):
        """Crear el contenido de la pestaÃ±a principal"""
        # Frame superior
        frame_superior = ctk.CTkFrame(self.pestaÃ±a_principal)
        frame_superior.pack(fill="x", padx=20, pady=10)

        # Checkbox para modo comprimido
        self.check_comprimir = ctk.CTkCheckBox(
            frame_superior,
            text="Comprimir PDFs en ZIP",
            variable=self.modo_comprimido
        )
        self.check_comprimir.pack(side="left", padx=10)

        # Entrada para patrÃ³n de filtro
        ctk.CTkLabel(frame_superior, text="Filtro:").pack(side="left", padx=5)
        filtro_entry = ctk.CTkEntry(
            frame_superior, 
            textvariable=self.patron_filtro,
            width=150
        )
        filtro_entry.pack(side="left", padx=5)

        # BotÃ³n para seleccionar carpeta
        self.btn_seleccionar = ctk.CTkButton(
            frame_superior,
            text="Seleccionar Carpeta",
            command=self.seleccionar_carpeta
        )
        self.btn_seleccionar.pack(side="right", padx=10)

        # Barra de progreso
        self.barra_progreso = ctk.CTkProgressBar(self.pestaÃ±a_principal)
        self.barra_progreso.pack(fill="x", padx=20, pady=10)
        self.barra_progreso.set(0)

        # Estado
        self.lbl_estado = ctk.CTkLabel(
            self.pestaÃ±a_principal,
            text="Esperando selecciÃ³n de carpeta..."
        )
        self.lbl_estado.pack(pady=5)

        # Ãrea de detalles
        self.detalles = ctk.CTkTextbox(
            self.pestaÃ±a_principal,
            height=75
        )
        self.detalles.pack(fill="both", expand=True, padx=20, pady=20)

        # Footer
        self.crear_footer(self.pestaÃ±a_principal)

    def crear_footer(self, frame_padre):
        """Crear el pie de pÃ¡gina con crÃ©ditos"""
        creditos_interno = ctk.CTkFrame(frame_padre, fg_color="transparent")
        creditos_interno.pack(side="bottom", fill="x", pady=(10, 3))

        creditos_linea1 = ctk.CTkLabel(
            creditos_interno,
            text="Desarrollado por: Luis Fernando Moreno Montoya | 2024",
            font=ctk.CTkFont(size=13),
            text_color="#CCCCCC"
        )
        creditos_linea1.pack(pady=(10, 3))
        
        mensaje_frame = ctk.CTkFrame(creditos_interno, fg_color="transparent")
        mensaje_frame.pack(pady=(3, 10))

        parte1 = ctk.CTkLabel(
            mensaje_frame,
            text="Hecho con ",
            font=ctk.CTkFont(size=13),
            text_color="#CCCCCC"
        )
        parte1.pack(side="left")

        corazon = ctk.CTkLabel(
            mensaje_frame,
            text="â™¥",
            font=ctk.CTkFont(size=13),
            text_color="#FF0000"
        )
        corazon.pack(side="left")

        parte2 = ctk.CTkLabel(
            mensaje_frame,
            text=" por la productividad laboral y el cuidado del tiempo",
            font=ctk.CTkFont(size=13),
            text_color="#CCCCCC"
        )
        parte2.pack(side="left")
        
        return creditos_interno

    def descargar_plantilla(self):
        """Descargar plantilla Excel"""
        try:
            ruta = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                filetypes=[("Excel files", "*.xlsx")],
                title="Guardar plantilla Excel"
            )
            if ruta:
                exito, mensaje = self.folder_creator.crear_plantilla(ruta)
                if exito:
                    agregar_detalle(self.detalles_carpetas, mensaje, "success")
                    messagebox.showinfo("Ã‰xito", mensaje)
                else:
                    agregar_detalle(self.detalles_carpetas, mensaje, "error")
                    messagebox.showerror("Error", mensaje)
        except Exception as e:
            agregar_detalle(self.detalles_carpetas, f"Error: {str(e)}", "error")
            messagebox.showerror("Error", str(e))

    def crear_carpetas(self):
        """Crear carpetas desde plantilla Excel"""
        # Seleccionar archivo Excel
        ruta_excel = filedialog.askopenfilename(
            title="Seleccionar Plantilla Excel",
            filetypes=[("Archivos Excel", "*.xlsx *.xls")]
        )
        
        if not ruta_excel:
            return
        
        # Seleccionar directorio de salida
        directorio_salida = filedialog.askdirectory(
            title="Seleccionar Directorio de Salida"
        )
        
        if not directorio_salida:
            return
        
        # Clase de callbacks personalizada
        class FolderCreationCallbacks:
            def __init__(self, gui):
                self.gui = gui
                self.detalles_carpetas = []
            
            def on_folder_created(self, nombre_carpeta):
                detalle = f"Carpeta creada: {nombre_carpeta}"
                self.detalles_carpetas.append(detalle)
                agregar_detalle(self.gui.detalles_carpetas, detalle, "success")
            
            def on_folder_exists(self, nombre_carpeta):
                detalle = f"Carpeta ya existente: {nombre_carpeta}"
                self.detalles_carpetas.append(detalle)
                agregar_detalle(self.gui.detalles_carpetas, detalle, "warning")
            
            def on_folder_error(self, nombre_carpeta, error):
                detalle = f"Error al crear carpeta {nombre_carpeta}: {error}"
                self.detalles_carpetas.append(detalle)
                agregar_detalle(self.gui.detalles_carpetas, detalle, "error")
        
        # Crear callbacks
        callbacks = FolderCreationCallbacks(self)
        
        # Procesar plantilla
        try:
            exito, mensaje = self.folder_creator.procesar_plantilla(
                ruta_excel, 
                directorio_salida,
                callbacks
            )
            
            # Mostrar mensaje de resultado
            if exito:
                messagebox.showinfo("Ã‰xito", mensaje)
            else:
                messagebox.showerror("Error", mensaje)
        
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def seleccionar_carpeta(self):
        """Seleccionar carpeta para procesar imÃ¡genes"""
        if self.procesando:
            self.pdf_converter.cancelar_proceso()
            self.btn_seleccionar.configure(text="Seleccionar Carpeta")
            self.procesando = False
            return
            
        directorio = filedialog.askdirectory()
        if not directorio:
            return
            
        # Validar directorio
        valido, mensaje = validar_directorio(directorio)
        if not valido:
            messagebox.showerror("Error", mensaje)
            return
        
        # Configurar callbacks
        class Callbacks:
            def __init__(self):
                self.started = False
                self.files_found = 0
                self.converted = []
                self.errors = []
                
            def on_start(self):
                self.lbl_estado.configure(text="Iniciando proceso...")
                self.btn_seleccionar.configure(text="Cancelar")
                agregar_detalle(self.detalles, "Iniciando proceso...", "info")
                
            def on_no_images(self):
                self.lbl_estado.configure(text="No se encontraron imÃ¡genes")
                messagebox.showinfo("Info", "No se encontraron imÃ¡genes")
                
            def on_images_found(self, total):
                self.lbl_estado.configure(text=f"Encontradas {total} imÃ¡genes")
                agregar_detalle(self.detalles, f"Encontradas {total} imÃ¡genes", "info")
                
            def on_processing_file(self, nombre):
                self.lbl_estado.configure(text=f"Procesando: {nombre}")
                
            def on_progress(self, valor):
                actualizar_progreso(self.barra_progreso, valor)
                
            def on_file_converted(self, nombre):
                agregar_detalle(self.detalles, f"Convertido: {nombre}", "success")
                
            def on_file_error(self, nombre, error):
                agregar_detalle(self.detalles, f"Error en {nombre}: {error}", "error")
                
            def on_complete(self, convertidas, total, errores, modo_comprimido):
                mensaje = f"Proceso completado. Convertidas {convertidas} de {total} imÃ¡genes"
                if errores > 0:
                    mensaje += f" ({errores} errores)"
                self.lbl_estado.configure(text=mensaje)
                agregar_detalle(self.detalles, mensaje, "success")
                
            def on_creating_zip(self):
                self.lbl_estado.configure(text="Creando archivo ZIP...")
                agregar_detalle(self.detalles, "Creando archivo ZIP...", "info")
                
            def on_zip_created(self, ruta):
                agregar_detalle(self.detalles, f"ZIP creado en: {ruta}", "success")
                
            def on_error(self, error):
                messagebox.showerror("Error", f"Error: {error}")
                agregar_detalle(self.detalles, f"Error: {error}", "error")
                
            def on_finish(self):
                self.procesando = False
                self.btn_seleccionar.configure(text="Seleccionar Carpeta")
                
        callbacks = Callbacks()
        callbacks.__dict__.update(self.__dict__)
        
        # Iniciar procesamiento
        self.procesando = True
        if self.modo_comprimido.get():
            # Solicitar ubicaciÃ³n para el ZIP
            zip_path = filedialog.asksaveasfilename(
                defaultextension=".zip",
                filetypes=[("Archivo ZIP", "*.zip")],
                initialfile=f"PDFs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
            )
            if not zip_path:
                self.procesando = False
                return
            self.pdf_converter.directorio_salida = zip_path
            
        # Iniciar conversiÃ³n en un hilo separado
        threading.Thread(
            target=self.pdf_converter.procesar_carpeta,
            args=(directorio, self.modo_comprimido.get(), callbacks, self.patron_filtro.get())
        ).start()

    def iniciar(self):
        """Iniciar la aplicaciÃ³n"""
        self.ventana.mainloop()

```

## src\app\__init__.py
```


```

## src\app\pdf_converter.py
```
import os
import threading
from PIL import Image
import zipfile
from datetime import datetime
import tempfile
import shutil
import multiprocessing
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from ..utils.helpers import agregar_detalle, actualizar_progreso

class PDFConverter:
    # Extensiones de imagen soportadas
    EXTENSIONES_SOPORTADAS = {'.png', '.jpg', '.jpeg', '.bmp', '.tiff', '.webp', '.gif', '.heic', '.heif'}
    
    def __init__(self):
        self.procesando = False
        self.directorio_salida = None
        self.cancelar = False
        # Usar el nÃºmero de CPUs disponibles o un mÃ¡ximo de 4
        self.max_workers = min(multiprocessing.cpu_count(), 4)
        
    def es_imagen_valida(self, ruta):
        """Verifica si un archivo es una imagen vÃ¡lida basado en su extensiÃ³n"""
        return Path(ruta).suffix.lower() in self.EXTENSIONES_SOPORTADAS
    
    def encontrar_imagenes(self, directorio, patron="*"):
        """
        Encuentra todas las imÃ¡genes en el directorio y subdirectorios usando pathlib.
        
        Args:
            directorio (str): Ruta al directorio a buscar
            patron (str): PatrÃ³n para filtrar archivos (por defecto "*")
            
        Returns:
            list: Lista de rutas de imÃ¡genes encontradas
        """
        ruta = Path(directorio)
        imagenes = set()  # Usar set para evitar duplicados
        
        # Buscar todos los archivos recursivamente
        for archivo in ruta.rglob("*"):
            if archivo.is_file() and archivo.suffix.lower() in self.EXTENSIONES_SOPORTADAS:
                imagenes.add(archivo)
        
        # Convertir a lista y ordenar
        imagenes = sorted(imagenes)
        
        # Filtrar por patrÃ³n personalizado si es necesario
        if patron and patron != "*":
            from fnmatch import fnmatch
            imagenes = [
                img for img in imagenes 
                if fnmatch(img.name.lower(), patron.lower())
            ]
        
        return imagenes
    
    def convertir_imagen(self, ruta_imagen, directorio_destino):
        """Convierte una imagen a PDF"""
        try:
            nombre_archivo = Path(ruta_imagen).name
            nombre_base = Path(ruta_imagen).stem
            ruta_pdf = Path(directorio_destino) / f"{nombre_base}.pdf"
            
            # Crear directorios intermedios si no existen
            ruta_pdf.parent.mkdir(parents=True, exist_ok=True)
            
            # Abrir y convertir imagen
            with Image.open(ruta_imagen) as img:
                # Optimizar memoria para imÃ¡genes grandes
                if img.size[0] > 2000 or img.size[1] > 2000:
                    img.thumbnail((2000, 2000), Image.Resampling.LANCZOS)
                
                # Convertir a RGB si es necesario
                if img.mode in ('RGBA', 'LA', 'P', 'PA'):
                    img = img.convert('RGB')
                elif img.mode not in ('RGB', 'L'):
                    img = img.convert('RGB')
                
                # Guardar como PDF con compresiÃ³n optimizada
                img.save(str(ruta_pdf), 'PDF', resolution=100.0, optimize=True)
            return True, nombre_archivo, None
        except Exception as e:
            return False, nombre_archivo, str(e)
    
    def procesar_carpeta(self, directorio, modo_comprimido, callbacks, patron="*"):
        """Procesa todas las imÃ¡genes en la carpeta usando un thread pool"""
        temp_dir = None
        try:
            self.procesando = True
            self.cancelar = False
            callbacks.on_start()
            
            # Crear directorio temporal si es modo comprimido
            if modo_comprimido:
                temp_dir = tempfile.mkdtemp()
            
            # Encontrar todas las imÃ¡genes usando pathlib
            imagenes = self.encontrar_imagenes(directorio, patron)
            
            if not imagenes:
                callbacks.on_no_images()
                return
            
            total_imagenes = len(imagenes)
            callbacks.on_images_found(total_imagenes)
            convertidas = 0
            errores = 0
            
            # Directorio de destino para PDFs
            directorio_destino = temp_dir if modo_comprimido else directorio
            
            # Procesar imÃ¡genes en paralelo
            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                # Crear futuras para cada imagen
                futuros = {
                    executor.submit(self.convertir_imagen, str(img), directorio_destino): img 
                    for img in imagenes
                }
                
                # Procesar resultados conforme se completan
                for futuro in as_completed(futuros):
                    if self.cancelar:
                        break
                        
                    ruta_imagen = futuros[futuro]
                    try:
                        exito, nombre, error = futuro.result()
                        if exito:
                            convertidas += 1
                            callbacks.on_file_converted(nombre)
                        else:
                            errores += 1
                            callbacks.on_file_error(nombre, error)
                        
                        # Actualizar progreso
                        progreso = (convertidas + errores) / total_imagenes
                        callbacks.on_progress(progreso)
                        
                    except Exception as e:
                        errores += 1
                        nombre = Path(ruta_imagen).name
                        callbacks.on_file_error(nombre, str(e))
            
            # Si se cancelÃ³, limpiar y salir
            if self.cancelar:
                if temp_dir and os.path.exists(temp_dir):
                    shutil.rmtree(temp_dir)
                return
            
            # Crear ZIP si es necesario
            if modo_comprimido and temp_dir:
                callbacks.on_creating_zip()
                zip_path = self.directorio_salida or Path(directorio) / f"PDFs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
                
                with zipfile.ZipFile(str(zip_path), 'w', zipfile.ZIP_DEFLATED) as zipf:
                    temp_path = Path(temp_dir)
                    for pdf in temp_path.rglob('*.pdf'):
                        arcname = pdf.relative_to(temp_path)
                        zipf.write(pdf, arcname)
                
                callbacks.on_zip_created(str(zip_path))
                
                # Limpiar directorio temporal
                shutil.rmtree(temp_dir)
            
            callbacks.on_complete(convertidas, total_imagenes, errores, modo_comprimido)
            
        except Exception as e:
            callbacks.on_error(str(e))
        finally:
            self.procesando = False
            callbacks.on_finish()
    
    def cancelar_proceso(self):
        """Cancela el proceso actual"""
        self.cancelar = True

```

## src\core\__init__.py
```
"""
Core package initialization.
"""
from .image_processor import ImageProcessor
from .text_normalizer import TextNormalizer

__all__ = ['ImageProcessor', 'TextNormalizer']

```

## src\core\text_normalizer.py
```
"""
Text normalization module.
"""
import re
import unicodedata

class TextNormalizer:
    """Class for normalizing text."""
    
    def normalize_text(self, text: str) -> str:
        """Normalize text by removing accents and special characters.
        
        Args:
            text: Text to normalize
            
        Returns:
            Normalized text
        """
        # First, convert to uppercase
        text = text.upper()
        
        # Remove accents
        text = unicodedata.normalize('NFKD', text)
        text = text.encode('ASCII', 'ignore').decode('ASCII')
        
        # Normalize multiple spaces and trim
        text = re.sub(r'\s+', ' ', text).strip()
        
        # Replace specific punctuation
        text = text.replace(',', '')
        text = text.replace('.', '_')
        
        # Replace other special characters with underscore
        text = re.sub(r'[^A-Z0-9\s\-_]', '_', text)
        
        # Normalize multiple consecutive underscores or hyphens
        text = re.sub(r'[_\-]+', '-', text)
        
        # Trim leading/trailing hyphens or underscores
        text = text.strip('-_')
        
        return text

```

## src\core\image_processor.py
```
"""
Image processing module.
"""
import os
from typing import Callable, List
from PIL import Image
import zipfile
import tempfile
import shutil

class ImageProcessor:
    """Class for handling image processing operations."""
    
    def __init__(self):
        """Initialize the image processor."""
        self._should_cancel = False
        
    def cancel_processing(self):
        """Cancel current processing operation."""
        self._should_cancel = True
        
    def batch_convert_to_pdf(
        self,
        input_dir: str,
        output_file: str,
        pattern: str = "*",
        progress_callback: Callable[[int, int], None] = None,
        compress: bool = False
    ) -> None:
        """Convert all images in a directory to PDF.
        
        Args:
            input_dir: Input directory containing images
            output_file: Output PDF or ZIP file path
            pattern: Pattern to filter image files
            progress_callback: Callback for progress updates
            compress: Whether to compress output into ZIP
        """
        # Reset cancel flag
        self._should_cancel = False
        
        try:
            # Create temporary directory for processing
            with tempfile.TemporaryDirectory() as temp_dir:
                # Get list of image files
                image_files = self._get_image_files(input_dir, pattern)
                total_files = len(image_files)
                
                if not total_files:
                    raise ValueError("No se encontraron imÃ¡genes en la carpeta")
                
                # Preserve original directory structure
                root_dir_name = os.path.basename(input_dir)
                
                # Process each image
                processed_files = []
                for i, image_file in enumerate(image_files, 1):
                    # Check for cancellation
                    if self._should_cancel:
                        raise InterruptedError("OperaciÃ³n cancelada")
                    
                    # Preserve relative path
                    relative_path = os.path.relpath(image_file, input_dir)
                    relative_dir = os.path.dirname(relative_path)
                    
                    # Create corresponding directory in temp_dir
                    pdf_subdir = os.path.join(temp_dir, root_dir_name, relative_dir)
                    os.makedirs(pdf_subdir, exist_ok=True)
                    
                    # Convert image to PDF
                    pdf_filename = f"{os.path.splitext(os.path.basename(image_file))[0]}.pdf"
                    pdf_path = os.path.join(pdf_subdir, pdf_filename)
                    
                    self._convert_to_pdf(image_file, pdf_path)
                    processed_files.append(pdf_path)
                    
                    # Update progress
                    if progress_callback:
                        progress_callback(i, total_files)
                
                # Create final output
                if compress:
                    # Suggest filename based on root directory
                    suggested_filename = f"{root_dir_name}_PDFs.zip"
                    
                    # Modify output_file to use suggested filename if not specified
                    if not output_file.lower().endswith('.zip'):
                        output_file = os.path.join(
                            os.path.dirname(output_file), 
                            suggested_filename
                        )
                    
                    # Create ZIP with all PDFs, preserving directory structure
                    with zipfile.ZipFile(output_file, 'w', zipfile.ZIP_DEFLATED) as zf:
                        for root, _, files in os.walk(os.path.join(temp_dir, root_dir_name)):
                            for file in files:
                                file_path = os.path.join(root, file)
                                arcname = os.path.relpath(file_path, temp_dir)
                                zf.write(file_path, arcname)
                else:
                    # Suggest filename based on root directory
                    suggested_filename = f"{root_dir_name}.pdf"
                    
                    # Modify output_file to use suggested filename if not specified
                    if not output_file.lower().endswith('.pdf'):
                        output_file = os.path.join(
                            os.path.dirname(output_file), 
                            suggested_filename
                        )
                    
                    # Merge all PDFs into one
                    pdfs = [
                        f for f in processed_files 
                        if f.lower().endswith('.pdf')
                    ]
                    
                    # If only one PDF, just copy it
                    if len(pdfs) == 1:
                        shutil.copy2(pdfs[0], output_file)
                    elif len(pdfs) > 1:
                        self._merge_pdfs(pdfs, output_file)
                    
        except Exception as e:
            # Clean up any partial output
            if os.path.exists(output_file):
                os.remove(output_file)
            raise e
            
    def _get_image_files(self, directory: str, pattern: str) -> List[str]:
        """Get list of image files in directory.
        
        Args:
            directory: Directory to search
            pattern: Pattern to filter files
            
        Returns:
            List of image file paths
        """
        image_files = []
        
        for root, _, files in os.walk(directory):
            for file in files:
                # Check if file matches pattern
                if not self._matches_pattern(file, pattern):
                    continue
                    
                # Check if file is an image
                file_path = os.path.join(root, file)
                try:
                    with Image.open(file_path) as img:
                        img.verify()
                    image_files.append(file_path)
                except:
                    continue
                    
        return sorted(image_files)
        
    def _matches_pattern(self, filename: str, pattern: str) -> bool:
        """Check if filename matches pattern.
        
        Args:
            filename: Filename to check
            pattern: Pattern to match against
            
        Returns:
            True if filename matches pattern
        """
        from fnmatch import fnmatch
        return fnmatch(filename.lower(), pattern.lower())
        
    def _convert_to_pdf(self, image_path: str, output_path: str) -> None:
        """Convert single image to PDF.
        
        Args:
            image_path: Path to input image
            output_path: Path to output PDF
        """
        try:
            with Image.open(image_path) as img:
                # Convert to RGB if necessary
                if img.mode != 'RGB':
                    img = img.convert('RGB')
                # Save as PDF
                img.save(output_path, 'PDF', resolution=100.0)
        except Exception as e:
            raise ValueError(f"Error al convertir {image_path}: {str(e)}")
            
    def _merge_pdfs(self, pdf_files: List[str], output_file: str) -> None:
        """Merge multiple PDFs into one.
        
        Args:
            pdf_files: List of PDF files to merge
            output_file: Output PDF file path
        """
        # For now, just copy the first PDF
        # TODO: Implement proper PDF merging
        shutil.copy2(pdf_files[0], output_file)

```

## src\core\folder_creator.py
```
"""
MÃ³dulo unificado para creaciÃ³n de carpetas desde plantillas Excel.
"""
from typing import Tuple, Optional, Callable
import os
import pandas as pd
import customtkinter as ctk
from tkinter import filedialog, messagebox

from .text_normalizer import TextNormalizer

class FolderCreator:
    """Clase para crear carpetas desde plantillas Excel con validaciones robustas."""
    
    def __init__(self):
        """Inicializar el creador de carpetas."""
        self.text_normalizer = TextNormalizer()
        
    def crear_plantilla(self, ruta_plantilla: str) -> Tuple[bool, str]:
        """Crear una plantilla de Excel con columnas predefinidas.
        
        Args:
            ruta_plantilla: Ruta donde se guardarÃ¡ la plantilla
        
        Returns:
            Tupla con (Ã©xito, mensaje)
        """
        try:
            # Crear DataFrame con columnas estÃ¡ndar
            df = pd.DataFrame(columns=['ID', 'NOMBRES', 'APELLIDOS'])
            
            # Guardar plantilla
            df.to_excel(ruta_plantilla, index=False)
            
            return True, f"Plantilla creada en {ruta_plantilla}"
        
        except Exception as e:
            return False, f"Error al crear plantilla: {str(e)}"
    
    def crear_contenido_pestaÃ±a(self, parent: ctk.CTkFrame):
        """Create tab content."""
        frame = ctk.CTkFrame(parent)
        frame.pack(pady=10, padx=10, fill="both", expand=True)
        
        # Excel template selection
        self.btn_plantilla = ctk.CTkButton(
            frame,
            text="Cargar Plantilla Excel",
            command=self.cargar_plantilla
        )
        self.btn_plantilla.pack(pady=10)
        
        # Output directory selection
        self.btn_directorio = ctk.CTkButton(
            frame,
            text="Seleccionar Directorio de Salida",
            command=self.seleccionar_directorio_salida
        )
        self.btn_directorio.pack(pady=10)
        
        # Status area
        self.estado_text = ctk.CTkTextbox(frame, height=200)
        self.estado_text.pack(pady=10, fill="both", expand=True)
        self.estado_text.configure(state="disabled")
        
    def cargar_plantilla(self):
        """Load and process Excel template."""
        try:
            ruta_excel = filedialog.askopenfilename(
                title="Seleccionar plantilla Excel",
                filetypes=[("Excel files", "*.xlsx")]
            )
            if not ruta_excel:
                return
                
            directorio_salida = filedialog.askdirectory(
                title="Seleccionar directorio de salida"
            )
            if not directorio_salida:
                return
                
            # Procesar plantilla
            exito, mensaje = self.procesar_plantilla(ruta_excel, directorio_salida)
            if exito:
                messagebox.showinfo(
                    "Ã‰xito",
                    mensaje
                )
            else:
                messagebox.showerror(
                    "Error",
                    mensaje
                )
                
        except Exception as e:
            messagebox.showerror(
                "Error",
                f"Error al procesar plantilla: {str(e)}"
            )
            
    def seleccionar_directorio_salida(self):
        """Select output directory."""
        directorio = filedialog.askdirectory(
            title="Seleccionar directorio de salida"
        )
        if directorio:
            self.agregar_estado(f"Directorio seleccionado: {directorio}")
            
    def agregar_estado(self, texto: str):
        """Add text to status area."""
        self.estado_text.configure(state="normal")
        self.estado_text.insert("end", texto + "\n")
        self.estado_text.see("end")
        self.estado_text.configure(state="disabled")
        
    def procesar_plantilla(
        self, 
        ruta_excel: str, 
        directorio_salida: str, 
        callbacks: Optional[object] = None
    ) -> Tuple[bool, str]:
        """Procesar plantilla Excel y crear carpetas.
        
        Args:
            ruta_excel: Ruta al archivo Excel
            directorio_salida: Directorio donde se crearÃ¡n las carpetas
            callbacks: Objeto con mÃ©todos de callback
        
        Returns:
            Tupla con (Ã©xito, mensaje)
        """
        try:
            # Leer plantilla
            df = pd.read_excel(ruta_excel)
            
            # Validar columnas
            columnas_requeridas = ['ID', 'NOMBRES']
            for col in columnas_requeridas:
                if col not in df.columns:
                    raise ValueError(f"Columna '{col}' no encontrada en la plantilla")
            
            # Crear carpetas
            carpetas_creadas = 0
            carpetas_existentes = 0
            
            # Eliminar filas duplicadas
            df_unico = df.drop_duplicates(subset=['ID', 'NOMBRES'])
            
            for _, row in df.iterrows():  # Usar df original
                # Normalizar nombre
                nombre_base = f"{row['ID']} - {row['NOMBRES']}"
                
                # Agregar apellidos si existen
                if 'APELLIDOS' in df.columns and pd.notna(row.get('APELLIDOS', '')):
                    nombre_base += f" {row['APELLIDOS']}"
                
                # Normalizar nombre de carpeta
                nombre_carpeta = self.text_normalizer.normalize_text(nombre_base)
                ruta_carpeta = os.path.join(directorio_salida, nombre_carpeta)
                
                # Manejar carpetas existentes
                if os.path.exists(ruta_carpeta):
                    if hasattr(callbacks, 'on_folder_exists'):
                        callbacks.on_folder_exists(nombre_carpeta)
                    carpetas_existentes += 1
                    continue
                
                try:
                    # Crear carpeta
                    os.makedirs(ruta_carpeta, exist_ok=False)
                    carpetas_creadas += 1
                    
                    # Callback de carpeta creada
                    if hasattr(callbacks, 'on_folder_created'):
                        callbacks.on_folder_created(nombre_carpeta)
                
                except FileExistsError:
                    # Manejar carpetas existentes
                    if hasattr(callbacks, 'on_folder_exists'):
                        callbacks.on_folder_exists(nombre_carpeta)
                    carpetas_existentes += 1
                
                except PermissionError as e:
                    # Manejar errores de permisos
                    if hasattr(callbacks, 'on_folder_error'):
                        callbacks.on_folder_error(nombre_carpeta, str(e))
            
            # Mensaje de resumen
            mensaje = (
                f"Proceso completado. "
                f"Carpetas creadas: {carpetas_creadas}, "
                f"Carpetas existentes: {carpetas_existentes}"
            )
            
            return True, mensaje
        
        except Exception as e:
            # Manejar errores generales
            if hasattr(callbacks, 'on_folder_error'):
                callbacks.on_folder_error('', str(e))
            
            return False, str(e)

```

## .pytest_cache\v\cache\stepwise
```
[]
```

## .pytest_cache\v\cache\nodeids
```
[
  "tests/test_cases/test_text_normalizer.py::TestTextNormalizer::test_basic_cases",
  "tests/test_cases/test_text_normalizer.py::TestTextNormalizer::test_edge_cases",
  "tests/test_cases/test_text_normalizer.py::TestTextNormalizer::test_folder_creation_from_template",
  "tests/test_cases/test_text_normalizer.py::TestTextNormalizer::test_special_chars",
  "tests/test_cases/test_text_normalizer.py::TestTextNormalizer::test_special_ids",
  "tests/test_executable.py::test_executable",
  "tests/test_folder_creator.py::test_folder_creation",
  "tests/test_helpers.py::TestHelpers::test_actualizar_progreso",
  "tests/test_helpers.py::TestHelpers::test_agregar_detalle",
  "tests/test_helpers.py::TestHelpers::test_generar_nombre_zip",
  "tests/test_helpers.py::TestHelpers::test_validar_directorio",
  "tests/test_image_processor.py::test_convert_to_pdf",
  "tests/test_image_processor.py::test_find_images",
  "tests/test_image_processor.py::test_get_image_info",
  "tests/test_image_processor.py::test_is_supported_format",
  "tests/test_image_processor.py::test_supported_formats",
  "tests/test_text_normalizer.py::TestTextNormalizer::test_normalize_text_with_accents",
  "tests/test_text_normalizer.py::TestTextNormalizer::test_normalize_text_with_multiple_spaces",
  "tests/test_text_normalizer.py::TestTextNormalizer::test_normalize_text_with_special_chars"
]
```

## .pytest_cache\v\cache\lastfailed
```
{
  "tests/test_casos.py": true,
  "tests/test_creacion_carpetas.py": true,
  "tests/test_imagen_a_pdf.py": true,
  "tests/test_nombres.py": true,
  "tests/test_normalizacion.py": true,
  "tests/test_normalizar.py": true,
  "tests/test_pdf_converter.py": true,
  "tests/test_cases/test_text_normalizer.py::TestTextNormalizer::test_basic_cases": true,
  "tests/test_cases/test_text_normalizer.py::TestTextNormalizer::test_edge_cases": true,
  "tests/test_cases/test_text_normalizer.py::TestTextNormalizer::test_special_ids": true,
  "tests/test_folder_creator.py::test_folder_creation": true,
  "tests/test_image_processor.py::test_get_image_info": true,
  "tests/test_image_processor.py::test_convert_to_pdf": true,
  "tests/test_text_normalizer.py::TestTextNormalizer::test_normalize_text_with_accents": true,
  "tests/test_text_normalizer.py::TestTextNormalizer::test_normalize_text_with_multiple_spaces": true,
  "tests/test_text_normalizer.py::TestTextNormalizer::test_normalize_text_with_special_chars": true
}
```

## .pytest_cache\README.md
```
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

```

## .pytest_cache\CACHEDIR.TAG
```
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

```

